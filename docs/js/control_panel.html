<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BrionetteZero - Motor Control Panel</title>
  
  <!-- DaisyUI v5 + TailwindCSS v4 (‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏Ñ‡∏π‡πà‡∏Å‡∏±‡∏ô!) -->
  <link href="https://cdn.jsdelivr.net/npm/daisyui@5" rel="stylesheet" type="text/css" />
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  
  <!-- LiteGraph.js -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/litegraph.js@0.7.18/css/litegraph.css" />
  <script src="https://cdn.jsdelivr.net/npm/litegraph.js@0.7.18/build/litegraph.min.js"></script>
  
  <!-- Three.js for 3D Simulation -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  
  <!-- Motor Controller -->
  <script src="../motor_controller.js"></script>
  
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }
    
    /* LiteGraph Canvas Styling */
    #graph-canvas {
      width: 100%;
      height: 100%;
      background: #1e1e2e;
    }
    
    .litegraph canvas {
      background: #181825 !important;
    }
    
    /* Custom scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #1e1e2e;
    }
    ::-webkit-scrollbar-thumb {
      background: #45475a;
      border-radius: 4px;
    }
    
    /* Connection status indicator */
    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    .status-dot.connected {
      background: #a6e3a1;
    }
    .status-dot.disconnected {
      background: #f38ba8;
      animation: none;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* Log container */
    #log-container {
      max-height: 200px;
      overflow-y: auto;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
    }
    
    .log-entry {
      padding: 2px 8px;
      border-bottom: 1px solid #313244;
    }
    .log-info { color: #89b4fa; }
    .log-warning { color: #f9e2af; }
    .log-error { color: #f38ba8; }
    .log-aux { color: #cba6f7; }
    
    /* Command Block Styling */
    .cmd-block {
      padding: 8px 10px;
      background: linear-gradient(135deg, #313244 0%, #45475a 100%);
      border: 1px solid #585b70;
      border-radius: 8px;
      cursor: grab;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
      user-select: none;
    }
    .cmd-block:hover {
      background: linear-gradient(135deg, #45475a 0%, #585b70 100%);
      border-color: #89b4fa;
      transform: translateX(3px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .cmd-block:active {
      cursor: grabbing;
      transform: scale(0.98);
    }
    .cmd-block.dragging {
      opacity: 0.5;
      transform: scale(0.95);
    }
    
    /* Special command styles */
    .cmd-block.cmd-stop {
      background: linear-gradient(135deg, #45293a 0%, #5c3a4a 100%);
      border-color: #f38ba8;
    }
    .cmd-block.cmd-stop:hover {
      background: linear-gradient(135deg, #5c3a4a 0%, #734a5a 100%);
    }
    .cmd-block.cmd-emergency {
      background: linear-gradient(135deg, #4a2020 0%, #6a3030 100%);
      border-color: #ff6b6b;
    }
    .cmd-block.cmd-emergency:hover {
      background: linear-gradient(135deg, #6a3030 0%, #8a4040 100%);
      animation: emergency-pulse 0.5s infinite;
    }
    
    @keyframes emergency-pulse {
      0%, 100% { border-color: #ff6b6b; }
      50% { border-color: #ff0000; }
    }
    
    /* Collapse styling for command panel */
    #command-panel .collapse-title {
      padding: 8px 12px;
      min-height: unset;
    }
    #command-panel .collapse-content {
      padding-bottom: 8px;
    }
    
    /* Drop zone highlight */
    #graph-canvas.drag-over {
      outline: 3px dashed #89b4fa;
      outline-offset: -3px;
    }
  </style>
</head>
<body class="bg-base-300">
  
  <!-- Main Drawer Layout -->
  <div class="drawer lg:drawer-open h-full">
    <input id="sidebar-drawer" type="checkbox" class="drawer-toggle" />
    
    <!-- Main Content Area -->
    <div class="drawer-content flex flex-col h-full">
      
      <!-- Top Navbar -->
      <div class="navbar bg-base-100 shadow-lg z-20">
        <div class="navbar-start">
          <label for="sidebar-drawer" class="btn btn-square btn-ghost lg:hidden">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="inline-block w-6 h-6 stroke-current">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
            </svg>
          </label>
          <a class="btn btn-ghost text-xl font-bold">
            <span class="text-primary">Brionette</span><span class="text-secondary">Zero</span>
          </a>
        </div>
        
        <div class="navbar-center hidden md:flex">
          <div class="flex items-center gap-2">
            <div id="status-indicator" class="status-dot disconnected"></div>
            <span id="status-text" class="text-sm">Disconnected</span>
          </div>
        </div>
        
        <div class="navbar-end gap-2">
          <button id="btn-connect" class="btn btn-primary btn-sm">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
            Connect
          </button>
          <button id="btn-emergency" class="btn btn-error btn-sm" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
            E-STOP
          </button>
        </div>
      </div>
      
      <!-- Tab Navigation -->
      <div class="tabs tabs-bordered bg-base-200 px-4">
        <button class="tab tab-active" data-tab="control">üéõÔ∏è Control</button>
        <button class="tab" data-tab="monitor">üìä Monitor</button>
        <button class="tab" data-tab="bench">üîß Bench Tools</button>
        <button class="tab" data-tab="settings">‚öôÔ∏è Settings</button>
      </div>
      
      <!-- Tab Contents -->
      <div id="tab-control" class="tab-panel bg-base-100 p-0 h-[calc(100vh-140px)] flex">
          <!-- Quick Controls Panel (Left Side) -->
          <div class="w-56 bg-base-200 border-r border-base-300 overflow-y-auto p-3">
            <h3 class="font-bold text-sm mb-3 flex items-center gap-2 text-primary">
              ‚ö° Quick Controls
            </h3>
            
            <!-- Jog Controls -->
            <div class="card bg-base-300 p-2 mb-3">
              <p class="text-xs opacity-70 mb-2">XY Jog (mm)</p>
              <div class="grid grid-cols-3 gap-1">
                <div></div>
                <button class="btn btn-xs btn-ghost" data-jog-mm="Y:+">‚Üë</button>
                <div></div>
                <button class="btn btn-xs btn-ghost" data-jog-mm="X:-">‚Üê</button>
                <button class="btn btn-xs btn-primary" id="btn-stop">‚¨§</button>
                <button class="btn btn-xs btn-ghost" data-jog-mm="X:+">‚Üí</button>
                <div></div>
                <button class="btn btn-xs btn-ghost" data-jog-mm="Y:-">‚Üì</button>
                <div></div>
              </div>
            </div>
            
            <!-- Z Jog -->
            <div class="card bg-base-300 p-2 mb-3">
              <p class="text-xs opacity-70 mb-2">Z Jog</p>
              <div class="flex gap-2 justify-center">
                <button class="btn btn-xs btn-ghost" data-jog-mm="Z:+">Z+</button>
                <button class="btn btn-xs btn-ghost" data-jog-mm="Z:-">Z-</button>
              </div>
            </div>
            
            <!-- Jog Step Size -->
            <div class="form-control mb-3">
              <label class="label py-1">
                <span class="label-text text-xs">Step (mm)</span>
              </label>
              <select id="jog-step-mm" class="select select-bordered select-xs w-full">
                <option value="1">1 mm</option>
                <option value="5">5 mm</option>
                <option value="10" selected>10 mm</option>
                <option value="25">25 mm</option>
                <option value="50">50 mm</option>
              </select>
            </div>
            
            <!-- Go To Position -->
            <div class="mb-3">
              <p class="text-xs font-semibold mb-2">Go To (mm)</p>
              <div class="grid grid-cols-3 gap-1 mb-2">
                <input type="number" id="goto-x" placeholder="X" class="input input-bordered input-xs" />
                <input type="number" id="goto-y" placeholder="Y" class="input input-bordered input-xs" />
                <input type="number" id="goto-z" placeholder="Z" class="input input-bordered input-xs" />
              </div>
              <button id="btn-goto" class="btn btn-primary btn-xs w-full">Go</button>
            </div>
            
            <div class="divider my-2"></div>
            
            <!-- Current Position -->
            <div class="mb-3">
              <p class="text-xs font-semibold mb-2">Position (mm)</p>
              <div class="grid grid-cols-3 gap-1 text-xs text-center">
                <div class="bg-base-300 rounded p-1">
                  <span class="opacity-50">X</span><br>
                  <span id="pos-x-mm">0.00</span>
                </div>
                <div class="bg-base-300 rounded p-1">
                  <span class="opacity-50">Y</span><br>
                  <span id="pos-y-mm">0.00</span>
                </div>
                <div class="bg-base-300 rounded p-1">
                  <span class="opacity-50">Z</span><br>
                  <span id="pos-z-mm">0.00</span>
                </div>
              </div>
            </div>
            
            <!-- Command Queue -->
            <div>
              <p class="text-xs font-semibold mb-2 flex items-center gap-1">
                üìã Queue <span class="badge badge-xs" id="queue-count">0</span>
              </p>
              <div id="queue-list" class="bg-base-300 rounded p-2 max-h-24 overflow-y-auto text-xs font-mono">
                <p class="opacity-50">Empty</p>
              </div>
            </div>
          </div>
          
          <!-- LiteGraph Canvas -->
          <div class="flex-1 relative">
            <canvas id="graph-canvas"></canvas>
          </div>
          
          <!-- Command Panel (Right Side) -->
          <div id="command-panel" class="w-64 bg-base-200 border-l border-base-300 overflow-y-auto p-3">
            <h3 class="font-bold text-sm mb-3 flex items-center gap-2 text-primary">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
              </svg>
              Command Blocks
            </h3>
            <p class="text-xs opacity-60 mb-3">Drag blocks to canvas</p>
            
            <!-- Movement Commands -->
            <div class="collapse collapse-arrow bg-base-300 mb-2">
              <input type="checkbox" checked />
              <div class="collapse-title text-sm font-semibold py-2 min-h-0">
                üöÄ Movement
              </div>
              <div class="collapse-content space-y-1 px-2">
                <div class="cmd-block" draggable="true" data-node="motor/move">
                  <span class="badge badge-primary badge-xs">XYZ</span> Move All
                </div>
                <div class="cmd-block" draggable="true" data-node="motor/move_xy">
                  <span class="badge badge-primary badge-xs">XY</span> Move XY
                </div>
                <div class="cmd-block" draggable="true" data-node="motor/move_single">
                  <span class="badge badge-info badge-xs">1</span> Move Motor
                </div>
                <div class="cmd-block" draggable="true" data-node="motor/move_relative">
                  <span class="badge badge-secondary badge-xs">¬±</span> Relative Move
                </div>
              </div>
            </div>
            
            <!-- Control Commands -->
            <div class="collapse collapse-arrow bg-base-300 mb-2">
              <input type="checkbox" checked />
              <div class="collapse-title text-sm font-semibold py-2 min-h-0">
                ‚ö° Control
              </div>
              <div class="collapse-content space-y-1 px-2">
                <div class="cmd-block cmd-stop" draggable="true" data-node="motor/stop">
                  <span class="badge badge-error badge-xs">!</span> Stop
                </div>
                <div class="cmd-block cmd-emergency" draggable="true" data-node="motor/emergency">
                  <span class="badge badge-error badge-xs">‚ö†</span> E-Stop
                </div>
                <div class="cmd-block" draggable="true" data-node="motor/set_home">
                  <span class="badge badge-success badge-xs">H</span> Set Home
                </div>
                <div class="cmd-block" draggable="true" data-node="motor/wait_idle">
                  <span class="badge badge-warning badge-xs">‚è≥</span> Wait Idle
                </div>
                <div class="cmd-block" draggable="true" data-node="motor/enable">
                  <span class="badge badge-success badge-xs">ON</span> Enable
                </div>
                <div class="cmd-block" draggable="true" data-node="motor/disable">
                  <span class="badge badge-neutral badge-xs">OFF</span> Disable
                </div>
              </div>
            </div>
            
            <!-- Config Commands -->
            <div class="collapse collapse-arrow bg-base-300 mb-2">
              <input type="checkbox" />
              <div class="collapse-title text-sm font-semibold py-2 min-h-0">
                ‚öôÔ∏è Config
              </div>
              <div class="collapse-content space-y-1 px-2">
                <div class="cmd-block" draggable="true" data-node="motor/set_speed">
                  <span class="badge badge-accent badge-xs">x</span> Set Speed
                </div>
                <div class="cmd-block" draggable="true" data-node="motor/set_accel">
                  <span class="badge badge-accent badge-xs">a</span> Set Accel
                </div>
                <div class="cmd-block" draggable="true" data-node="motor/calibrate">
                  <span class="badge badge-warning badge-xs">‚ö°</span> Calibrate
                </div>
              </div>
            </div>
            
            <!-- Info Commands -->
            <div class="collapse collapse-arrow bg-base-300 mb-2">
              <input type="checkbox" />
              <div class="collapse-title text-sm font-semibold py-2 min-h-0">
                üìä Info
              </div>
              <div class="collapse-content space-y-1 px-2">
                <div class="cmd-block" draggable="true" data-node="motor/position">
                  <span class="badge badge-info badge-xs">p</span> Position
                </div>
                <div class="cmd-block" draggable="true" data-node="motor/status">
                  <span class="badge badge-info badge-xs">d</span> Status
                </div>
                <div class="cmd-block" draggable="true" data-node="motor/limit">
                  <span class="badge badge-info badge-xs">l</span> Limit Status
                </div>
              </div>
            </div>
            
            <!-- AUX Commands -->
            <div class="collapse collapse-arrow bg-base-300 mb-2">
              <input type="checkbox" />
              <div class="collapse-title text-sm font-semibold py-2 min-h-0">
                üîß AUX Tool
              </div>
              <div class="collapse-content space-y-1 px-2">
                <div class="cmd-block" draggable="true" data-node="motor/aux_command">
                  <span class="badge badge-secondary badge-xs">m</span> AUX Command
                </div>
                <div class="cmd-block" draggable="true" data-node="motor/aux_query">
                  <span class="badge badge-secondary badge-xs">?</span> Query Tool
                </div>
              </div>
            </div>
            
            <!-- Utility Nodes -->
            <div class="collapse collapse-arrow bg-base-300 mb-2">
              <input type="checkbox" checked />
              <div class="collapse-title text-sm font-semibold py-2 min-h-0">
                üîß Utility
              </div>
              <div class="collapse-content space-y-1 px-2">
                <div class="cmd-block" draggable="true" data-node="util/button">
                  <span class="badge badge-primary badge-xs">‚ñ∂</span> Button
                </div>
                <div class="cmd-block" draggable="true" data-node="util/delay">
                  <span class="badge badge-warning badge-xs">‚è±</span> Delay
                </div>
                <div class="cmd-block" draggable="true" data-node="util/number">
                  <span class="badge badge-accent badge-xs">#</span> Number
                </div>
                <div class="cmd-block" draggable="true" data-node="util/loop">
                  <span class="badge badge-info badge-xs">üîÑ</span> Loop
                </div>
                <div class="cmd-block" draggable="true" data-node="util/sequence">
                  <span class="badge badge-info badge-xs">‚Üí</span> Sequence
                </div>
                <div class="cmd-block" draggable="true" data-node="util/comment">
                  <span class="badge badge-neutral badge-xs">üí¨</span> Comment
                </div>
              </div>
            </div>
            
            <!-- Simulate & Generate -->
            <div class="divider my-2"></div>
            <button id="btn-generate-simulate" class="btn btn-secondary btn-sm w-full mb-2">
              üéÆ Generate & Simulate
            </button>
            <button id="btn-run-graph" class="btn btn-primary btn-sm w-full mb-2">
              ‚ñ∂Ô∏è Run Graph
            </button>
            
            <!-- Save/Load -->
            <div class="divider my-2"></div>
            <div class="flex gap-2">
              <button id="btn-save-nodes" class="btn btn-outline btn-sm flex-1">
                üíæ Save Nodes
              </button>
              <button id="btn-load-nodes" class="btn btn-outline btn-sm flex-1">
                üìÇ Load Nodes
              </button>
            </div>
            <button id="btn-save-config" class="btn btn-outline btn-accent btn-sm w-full mt-2">
              ‚öôÔ∏è Save All Config
            </button>
            <input type="file" id="load-nodes-input" accept=".json" class="hidden">
            
          </div>
      </div>

      <div id="tab-monitor" class="tab-panel hidden bg-base-100 p-4 h-[calc(100vh-140px)] overflow-auto">
          <!-- Motor Status Cards -->
          <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
            <!-- Motor 1 -->
            <div class="card bg-base-200 shadow-xl">
              <div class="card-body">
                <h2 class="card-title">
                  <span class="badge badge-primary">X</span> Motor 1
                </h2>
                <div class="stats stats-vertical shadow">
                  <div class="stat">
                    <div class="stat-title">Position</div>
                    <div class="stat-value text-primary" id="m1-position">0</div>
                    <div class="stat-desc">steps</div>
                  </div>
                  <div class="stat">
                    <div class="stat-title">Status</div>
                    <div class="stat-value text-lg" id="m1-status">UNKNOWN</div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Motor 2 -->
            <div class="card bg-base-200 shadow-xl">
              <div class="card-body">
                <h2 class="card-title">
                  <span class="badge badge-secondary">Y</span> Motor 2
                </h2>
                <div class="stats stats-vertical shadow">
                  <div class="stat">
                    <div class="stat-title">Position</div>
                    <div class="stat-value text-secondary" id="m2-position">0</div>
                    <div class="stat-desc">steps</div>
                  </div>
                  <div class="stat">
                    <div class="stat-title">Status</div>
                    <div class="stat-value text-lg" id="m2-status">UNKNOWN</div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Motor 3 -->
            <div class="card bg-base-200 shadow-xl">
              <div class="card-body">
                <h2 class="card-title">
                  <span class="badge badge-accent">Z</span> Motor 3
                </h2>
                <div class="stats stats-vertical shadow">
                  <div class="stat">
                    <div class="stat-title">Position</div>
                    <div class="stat-value text-accent" id="m3-position">0</div>
                    <div class="stat-desc">steps</div>
                  </div>
                  <div class="stat">
                    <div class="stat-title">Status</div>
                    <div class="stat-value text-lg" id="m3-status">UNKNOWN</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Log Output -->
          <div class="card bg-base-200 shadow-xl">
            <div class="card-body">
              <h2 class="card-title">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
                Serial Log
                <button id="btn-clear-log" class="btn btn-xs btn-ghost ml-auto">Clear</button>
              </h2>
              <div id="log-container" class="bg-base-300 rounded-lg p-2 font-mono"></div>
            </div>
          </div>
      </div>

      <div id="tab-bench" class="tab-panel hidden bg-base-100 p-4 h-[calc(100vh-140px)] overflow-auto">
          <!-- Bench Tools Content -->
          <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
            <!-- Bench Grid Creator -->
            <div class="card bg-base-200 shadow-xl">
              <div class="card-body">
                <h2 class="card-title">üß™ Create Bench Grid</h2>
                <p class="text-xs opacity-70">Create a grid layout for lab equipment (each cell is 140mm)</p>
                <div class="grid grid-cols-2 gap-4 mt-2">
                  <div class="form-control">
                    <label class="label"><span class="label-text">Columns</span></label>
                    <input type="number" id="bench-cols" class="input input-bordered input-sm" value="3" min="1" max="10" />
                  </div>
                  <div class="form-control">
                    <label class="label"><span class="label-text">Rows</span></label>
                    <input type="number" id="bench-rows" class="input input-bordered input-sm" value="2" min="1" max="10" />
                  </div>
                </div>
                <div class="card-actions justify-end mt-4">
                  <button id="btn-create-grid" class="btn btn-primary btn-sm">Create Grid</button>
                </div>
              </div>
            </div>
            
            <!-- Component List -->
            <div class="card bg-base-200 shadow-xl">
              <div class="card-body">
                <h2 class="card-title">üì¶ Components</h2>
                <p class="text-xs opacity-70">Click component to assign to grid, ‚öôÔ∏è for settings</p>
                <div class="space-y-2 mt-2">
                  <div class="flex items-center gap-2 p-2 bg-base-300 rounded-lg">
                    <div class="flex-1 cursor-pointer hover:bg-primary/20 rounded component-item" data-component="tip-box-96">
                      <div class="font-semibold text-sm">üß™ 96 Tip Box (200¬µL)</div>
                      <div class="text-xs opacity-70">8x12 grid of pipette tips</div>
                    </div>
                    <button class="btn btn-ghost btn-xs btn-square" onclick="openComponentSettings('tipBox96')">‚öôÔ∏è</button>
                  </div>
                  <div class="flex items-center gap-2 p-2 bg-base-300 rounded-lg">
                    <div class="flex-1 cursor-pointer hover:bg-primary/20 rounded component-item" data-component="wellplate-96">
                      <div class="font-semibold text-sm">üß´ 96 Well Plate</div>
                      <div class="text-xs opacity-70">Standard microplate</div>
                    </div>
                    <button class="btn btn-ghost btn-xs btn-square" onclick="openComponentSettings('wellPlate96')">‚öôÔ∏è</button>
                  </div>
                  <div class="flex items-center gap-2 p-2 bg-base-300 rounded-lg">
                    <div class="flex-1 cursor-pointer hover:bg-primary/20 rounded component-item" data-component="reservoir">
                      <div class="font-semibold text-sm">ü´ó Reservoir</div>
                      <div class="text-xs opacity-70">Single channel reservoir</div>
                    </div>
                    <button class="btn btn-ghost btn-xs btn-square" onclick="openComponentSettings('reservoir')">‚öôÔ∏è</button>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Bench Grid Display -->
            <div class="card bg-base-200 shadow-xl lg:col-span-2">
              <div class="card-body">
                <h2 class="card-title">üó∫Ô∏è Bench Layout</h2>
                <div id="bench-grid-container" class="grid gap-2 p-4 bg-base-300 rounded-lg min-h-[200px]">
                  <p class="text-center opacity-50">Click "Create Grid" to start</p>
                </div>
              </div>
            </div>
          </div>
      </div>
      
      <div id="tab-settings" class="tab-panel hidden bg-base-100 p-4 h-[calc(100vh-140px)] overflow-auto">
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            
            <!-- Steps Per 100mm Settings -->
            <div class="card bg-base-200 shadow-xl">
              <div class="card-body">
                <h2 class="card-title">üéØ Steps Per 100mm</h2>
                <p class="text-xs opacity-70 mb-2">Required: Convert between millimeters and motor steps</p>
                <div class="form-control">
                  <label class="label">
                    <span class="label-text">Motor 1 (X)</span>
                    <span class="label-text-alt">steps/100mm</span>
                  </label>
                  <input type="number" id="steps-per-100mm-m1" class="input input-bordered input-sm" value="1600" min="1" required />
                </div>
                <div class="form-control mt-2">
                  <label class="label">
                    <span class="label-text">Motor 2 (Y)</span>
                    <span class="label-text-alt">steps/100mm</span>
                  </label>
                  <input type="number" id="steps-per-100mm-m2" class="input input-bordered input-sm" value="1600" min="1" required />
                </div>
                <div class="form-control mt-2">
                  <label class="label">
                    <span class="label-text">Motor 3 (Z)</span>
                    <span class="label-text-alt">steps/100mm</span>
                  </label>
                  <input type="number" id="steps-per-100mm-m3" class="input input-bordered input-sm" value="1600" min="1" required />
                </div>
                <div class="card-actions justify-end mt-4">
                  <button id="btn-save-steps" class="btn btn-primary btn-sm">Save to LocalStorage</button>
                </div>
              </div>
            </div>
            
            <!-- Motor Max Range -->
            <div class="card bg-base-200 shadow-xl">
              <div class="card-body">
                <h2 class="card-title">üìè Motor Max Range (mm)</h2>
                <p class="text-xs opacity-70 mb-2">Maximum travel distance for each axis</p>
                <div class="form-control">
                  <label class="label">
                    <span class="label-text">Motor 1 (X) Max</span>
                    <span class="label-text-alt">mm</span>
                  </label>
                  <input type="number" id="motor-max-m1" class="input input-bordered input-sm" value="300" min="1" />
                </div>
                <div class="form-control mt-2">
                  <label class="label">
                    <span class="label-text">Motor 2 (Y) Max</span>
                    <span class="label-text-alt">mm</span>
                  </label>
                  <input type="number" id="motor-max-m2" class="input input-bordered input-sm" value="300" min="1" />
                </div>
                <div class="form-control mt-2">
                  <label class="label">
                    <span class="label-text">Motor 3 (Z) Max</span>
                    <span class="label-text-alt">mm</span>
                  </label>
                  <input type="number" id="motor-max-m3" class="input input-bordered input-sm" value="100" min="1" />
                </div>
                <div class="card-actions justify-end mt-4">
                  <button id="btn-save-motor-max" class="btn btn-primary btn-sm">Save</button>
                </div>
              </div>
            </div>
            
            <!-- Bench Grid Settings -->
            <div class="card bg-base-200 shadow-xl">
              <div class="card-body">
                <h2 class="card-title">üß™ Bench Grid Settings</h2>
                <div class="form-control">
                  <label class="label">
                    <span class="label-text">Grid Cell Size</span>
                    <span class="label-text-alt">mm</span>
                  </label>
                  <input type="number" id="bench-cell-size" class="input input-bordered input-sm" value="140" min="10" />
                </div>
                <div class="card-actions justify-end mt-4">
                  <button id="btn-save-bench-settings" class="btn btn-primary btn-sm">Save</button>
                </div>
              </div>
            </div>
            
            <!-- Speed Settings -->
            <div class="card bg-base-200 shadow-xl">
              <div class="card-body">
                <h2 class="card-title">Speed & Acceleration</h2>
                <div class="form-control">
                  <label class="label">
                    <span class="label-text">Max Speed (steps/rev)</span>
                    <span class="label-text-alt" id="speed-value">3</span>
                  </label>
                  <input type="range" id="speed-slider" min="1" max="10" value="3" class="range range-primary" />
                </div>
                <div class="form-control mt-4">
                  <label class="label">
                    <span class="label-text">Acceleration</span>
                    <span class="label-text-alt" id="accel-value">1</span>
                  </label>
                  <input type="range" id="accel-slider" min="0.5" max="5" step="0.5" value="1" class="range range-secondary" />
                </div>
                <div class="card-actions justify-end mt-4">
                  <button id="btn-apply-settings" class="btn btn-primary btn-sm">Apply</button>
                </div>
              </div>
            </div>
            
            <!-- Calibration -->
            <div class="card bg-base-200 shadow-xl">
              <div class="card-body">
                <h2 class="card-title">Calibration</h2>
                <p class="text-sm opacity-70">Run full calibration to find home position and measure axis lengths.</p>
                <div class="card-actions justify-end mt-4">
                  <button id="btn-set-home" class="btn btn-ghost btn-sm">Set Home</button>
                  <button id="btn-calibrate" class="btn btn-warning btn-sm">Calibrate</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- 96 Well Plate Modal -->
    <dialog id="well-config-modal" class="modal">
      <div class="modal-box max-w-2xl">
        <h3 class="font-bold text-lg mb-4">üß™ 96 Tip Box Configuration</h3>
        
        <!-- Quick Actions -->
        <div class="flex gap-2 mb-4">
          <button id="well-select-all" class="btn btn-sm btn-primary">Select All</button>
          <button id="well-deselect-all" class="btn btn-sm btn-ghost">Deselect All</button>
          <button id="well-select-row" class="btn btn-sm btn-ghost">Select Row</button>
          <button id="well-select-col" class="btn btn-sm btn-ghost">Select Column</button>
          <span class="ml-auto badge badge-info" id="well-count">96/96 enabled</span>
        </div>
        
        <!-- Column Headers -->
        <div class="overflow-x-auto">
          <div class="grid gap-1" style="grid-template-columns: 30px repeat(12, 1fr);">
            <div></div>
            <div class="text-center text-xs font-bold opacity-70">1</div>
            <div class="text-center text-xs font-bold opacity-70">2</div>
            <div class="text-center text-xs font-bold opacity-70">3</div>
            <div class="text-center text-xs font-bold opacity-70">4</div>
            <div class="text-center text-xs font-bold opacity-70">5</div>
            <div class="text-center text-xs font-bold opacity-70">6</div>
            <div class="text-center text-xs font-bold opacity-70">7</div>
            <div class="text-center text-xs font-bold opacity-70">8</div>
            <div class="text-center text-xs font-bold opacity-70">9</div>
            <div class="text-center text-xs font-bold opacity-70">10</div>
            <div class="text-center text-xs font-bold opacity-70">11</div>
            <div class="text-center text-xs font-bold opacity-70">12</div>
          </div>
          
          <!-- Well Grid -->
          <div id="well-grid" class="grid gap-1 mt-1" style="grid-template-columns: 30px repeat(12, 1fr);"></div>
        </div>
        
        <div class="modal-action">
          <button id="well-config-cancel" class="btn btn-ghost">Cancel</button>
          <button id="well-config-save" class="btn btn-primary">Save</button>
        </div>
      </div>
      <form method="dialog" class="modal-backdrop">
        <button>close</button>
      </form>
    </dialog>
    
    <!-- Component Settings Modal -->
    <dialog id="component-settings-modal" class="modal">
      <div class="modal-box">
        <h3 class="font-bold text-lg mb-4" id="component-settings-title">‚öôÔ∏è Component Settings</h3>
        
        <div id="component-settings-content">
          <!-- Dynamic content based on component type -->
        </div>
        
        <div class="modal-action">
          <button class="btn btn-ghost" onclick="document.getElementById('component-settings-modal').close()">Cancel</button>
          <button class="btn btn-primary" id="btn-save-component-settings">Save</button>
        </div>
      </div>
      <form method="dialog" class="modal-backdrop">
        <button>close</button>
      </form>
    </dialog>
    
    <!-- Setup Wizard Modal (Cannot close until complete) -->
    <dialog id="setup-wizard-modal" class="modal">
      <div class="modal-box max-w-2xl">
        <!-- Progress Steps -->
        <ul class="steps steps-horizontal w-full mb-6">
          <li class="step step-primary" id="wizard-step-1">Connect</li>
          <li class="step" id="wizard-step-2">Calibrate</li>
          <li class="step" id="wizard-step-3">Settings</li>
          <li class="step" id="wizard-step-4">Complete</li>
        </ul>
        
        <!-- Step 1: Connect & Calibrate -->
        <div id="wizard-page-1" class="wizard-page">
          <h3 class="font-bold text-xl mb-4">üîå Step 1: Connect & Calibrate</h3>
          <p class="mb-4 opacity-70">Connect to the motor controller and run calibration to measure axis lengths.</p>
          
          <div class="alert alert-info mb-4">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            <span>Make sure your motor controller is connected via USB.</span>
          </div>
          
          <div class="flex flex-col gap-4">
            <div class="flex items-center gap-4">
              <button id="wizard-btn-connect" class="btn btn-primary">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
                Connect
              </button>
              <span id="wizard-connect-status" class="badge badge-ghost">Not Connected</span>
            </div>
            
            <div class="flex items-center gap-4">
              <button id="wizard-btn-calibrate" class="btn btn-warning" disabled>
                üéØ Run Calibration
              </button>
              <span id="wizard-calibrate-status" class="badge badge-ghost">Not Calibrated</span>
            </div>
            
            <div class="bg-base-200 p-4 rounded-lg mt-4">
              <h4 class="font-semibold mb-2">Calibration Results:</h4>
              <div class="grid grid-cols-3 gap-4 text-center">
                <div>
                  <p class="text-xs opacity-70">X Max Steps</p>
                  <p class="text-lg font-mono" id="wizard-x-steps">--</p>
                </div>
                <div>
                  <p class="text-xs opacity-70">Y Max Steps</p>
                  <p class="text-lg font-mono" id="wizard-y-steps">--</p>
                </div>
                <div>
                  <p class="text-xs opacity-70">Z Max Steps</p>
                  <p class="text-lg font-mono" id="wizard-z-steps">--</p>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Step 2: Steps Per 100mm & Bench Grid -->
        <div id="wizard-page-2" class="wizard-page hidden">
          <h3 class="font-bold text-xl mb-4">‚öôÔ∏è Step 2: Motor Settings & Bench Grid</h3>
          
          <fieldset class="fieldset bg-base-200 p-4 rounded-lg mb-4">
            <legend class="fieldset-legend">Steps Per 100mm</legend>
            <p class="text-xs opacity-70 mb-3">Enter the number of motor steps required to move 100mm</p>
            <div class="grid grid-cols-3 gap-4">
              <div class="form-control">
                <label class="label"><span class="label-text">Motor X</span></label>
                <input type="number" id="wizard-steps-x" class="input input-bordered" value="1600" min="1" />
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text">Motor Y</span></label>
                <input type="number" id="wizard-steps-y" class="input input-bordered" value="1600" min="1" />
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text">Motor Z</span></label>
                <input type="number" id="wizard-steps-z" class="input input-bordered" value="1600" min="1" />
              </div>
            </div>
          </fieldset>
          
          <fieldset class="fieldset bg-base-200 p-4 rounded-lg">
            <legend class="fieldset-legend">Bench Grid Configuration</legend>
            <p class="text-xs opacity-70 mb-3">Define the grid size for placing lab components</p>
            <div class="grid grid-cols-3 gap-4">
              <div class="form-control">
                <label class="label"><span class="label-text">Columns</span></label>
                <input type="number" id="wizard-grid-cols" class="input input-bordered" value="3" min="1" max="10" />
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text">Rows</span></label>
                <input type="number" id="wizard-grid-rows" class="input input-bordered" value="2" min="1" max="10" />
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text">Cell Size (mm)</span></label>
                <input type="number" id="wizard-cell-size" class="input input-bordered" value="140" min="50" />
              </div>
            </div>
          </fieldset>
        </div>
        
        <!-- Step 3: Max Values Summary -->
        <div id="wizard-page-3" class="wizard-page hidden">
          <h3 class="font-bold text-xl mb-4">üìä Step 3: Axis Limits Summary</h3>
          <p class="mb-4 opacity-70">Review and confirm the calculated axis limits.</p>
          
          <div class="overflow-x-auto">
            <table class="table table-zebra">
              <thead>
                <tr>
                  <th>Axis</th>
                  <th>Max Steps</th>
                  <th>Steps/100mm</th>
                  <th>Max Length (mm)</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td class="font-bold text-primary">X (Motor 1)</td>
                  <td id="wizard-sum-x-steps" class="font-mono">--</td>
                  <td id="wizard-sum-x-per100" class="font-mono">--</td>
                  <td id="wizard-sum-x-mm" class="font-mono font-bold text-success">--</td>
                </tr>
                <tr>
                  <td class="font-bold text-secondary">Y (Motor 2)</td>
                  <td id="wizard-sum-y-steps" class="font-mono">--</td>
                  <td id="wizard-sum-y-per100" class="font-mono">--</td>
                  <td id="wizard-sum-y-mm" class="font-mono font-bold text-success">--</td>
                </tr>
                <tr>
                  <td class="font-bold text-accent">Z (Motor 3)</td>
                  <td id="wizard-sum-z-steps" class="font-mono">--</td>
                  <td id="wizard-sum-z-per100" class="font-mono">--</td>
                  <td id="wizard-sum-z-mm" class="font-mono font-bold text-success">--</td>
                </tr>
              </tbody>
            </table>
          </div>
          
          <div class="alert alert-warning mt-4">
            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>
            <span>These values will be used for position calculations and safety limits.</span>
          </div>
        </div>
        
        <!-- Step 4: Complete -->
        <div id="wizard-page-4" class="wizard-page hidden">
          <div class="text-center py-8">
            <div class="text-6xl mb-4">üéâ</div>
            <h3 class="font-bold text-2xl mb-4 text-success">Setup Complete!</h3>
            <p class="opacity-70 mb-6">Your BrionetteZero is now configured and ready to use.</p>
            
            <div class="stats shadow bg-base-200">
              <div class="stat">
                <div class="stat-title">Work Area</div>
                <div class="stat-value text-primary" id="wizard-final-area">--</div>
                <div class="stat-desc">X √ó Y mm</div>
              </div>
              <div class="stat">
                <div class="stat-title">Z Height</div>
                <div class="stat-value text-secondary" id="wizard-final-z">--</div>
                <div class="stat-desc">mm</div>
              </div>
              <div class="stat">
                <div class="stat-title">Grid</div>
                <div class="stat-value text-accent" id="wizard-final-grid">--</div>
                <div class="stat-desc">cols √ó rows</div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Navigation Buttons -->
        <div class="modal-action justify-between">
          <button id="wizard-btn-prev" class="btn btn-ghost" disabled>‚Üê Previous</button>
          <button id="wizard-btn-next" class="btn btn-primary" disabled>Next ‚Üí</button>
          <button id="wizard-btn-finish" class="btn btn-success hidden">üöÄ Start Using</button>
        </div>
      </div>
      <!-- No backdrop close button - must complete wizard -->
    </dialog>
    
    <!-- 3D Simulator Modal -->
    <dialog id="simulator-modal" class="modal">
      <div class="modal-box max-w-6xl h-[80vh]">
        <h3 class="font-bold text-lg mb-4 flex items-center gap-2">
          üéÆ 3D Position Simulator
          <span class="badge badge-primary" id="sim-command-count">0 commands</span>
        </h3>
        
        <div class="flex gap-4 h-[calc(100%-120px)]">
          <!-- 3D View -->
          <div class="flex-1 bg-base-300 rounded-lg overflow-hidden relative">
            <div id="three-container" class="w-full h-full" style="touch-action: none;"></div>
            
            <!-- Position Overlay -->
            <div class="absolute top-4 left-4 bg-base-100/80 p-3 rounded-lg backdrop-blur pointer-events-none">
              <div class="text-xs opacity-70 mb-1">Current Position (mm)</div>
              <div class="font-mono text-sm">
                X: <span id="sim-pos-x" class="text-primary">0.00</span> |
                Y: <span id="sim-pos-y" class="text-secondary">0.00</span> |
                Z: <span id="sim-pos-z" class="text-accent">0.00</span>
              </div>
            </div>
            
            <!-- Controls Help -->
            <div class="absolute bottom-4 left-4 bg-base-100/60 px-3 py-2 rounded-lg backdrop-blur text-xs opacity-70 pointer-events-none">
              üñ±Ô∏è Drag to rotate | Scroll to zoom | Right-click to pan
            </div>
          </div>
          
          <!-- Command List with Tabs -->
          <div class="w-80 bg-base-200 rounded-lg overflow-hidden flex flex-col">
            <!-- Tabs -->
            <div class="tabs tabs-box bg-base-300">
              <button class="tab tab-active" id="tab-commands" onclick="switchCommandTab('commands')">Commands</button>
              <button class="tab" id="tab-raw" onclick="switchCommandTab('raw')">Raw</button>
            </div>
            
            <!-- Commands View -->
            <div id="view-commands" class="p-3 overflow-y-auto flex-1">
              <div id="sim-command-list" class="space-y-1 text-xs font-mono">
                <p class="opacity-50">No commands generated</p>
              </div>
            </div>
            
            <!-- Raw Commands View -->
            <div id="view-raw" class="p-3 overflow-y-auto flex-1 hidden">
              <pre id="sim-raw-commands" class="text-xs font-mono bg-base-300 p-2 rounded whitespace-pre-wrap">// Raw commands for motor_controller.js</pre>
            </div>
          </div>
        </div>
        
        <!-- Playback Controls -->
        <div class="flex items-center justify-center gap-4 mt-4">
          <button id="sim-btn-prev" class="btn btn-circle btn-outline">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
            </svg>
          </button>
          <button id="sim-btn-play" class="btn btn-circle btn-primary btn-lg">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
            </svg>
          </button>
          <button id="sim-btn-next" class="btn btn-circle btn-outline">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
            </svg>
          </button>
          
          <div class="divider divider-horizontal"></div>
          
          <div class="flex items-center gap-2">
            <span class="text-sm opacity-70">Step:</span>
            <span id="sim-current-step" class="font-mono badge badge-lg">0</span>
            <span class="text-sm opacity-70">/ <span id="sim-total-steps">0</span></span>
          </div>
          
          <div class="divider divider-horizontal"></div>
          
          <label class="flex items-center gap-2 cursor-pointer">
            <span class="text-sm">Speed:</span>
            <input type="range" id="sim-speed" min="0.5" max="10" step="0.5" value="1" class="range range-xs w-24" />
            <span id="sim-speed-value" class="text-sm font-mono">1x</span>
          </label>
        </div>
        
        <div class="modal-action">
          <button class="btn btn-ghost" onclick="document.getElementById('simulator-modal').close()">Close</button>
          <button id="sim-btn-run" class="btn btn-primary">üöÄ Run on Machine</button>
        </div>
      </div>
      <form method="dialog" class="modal-backdrop">
        <button>close</button>
      </form>
    </dialog>
    
    <!-- Sidebar -->
    <div class="drawer-side z-30">
      <label for="sidebar-drawer" aria-label="close sidebar" class="drawer-overlay"></label>
      <div class="menu bg-base-200 text-base-content min-h-full w-72 p-4">
        
        <!-- Quick Controls -->
        <div class="mb-4">
          <h3 class="font-bold text-lg mb-2 flex items-center gap-2">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
            Quick Controls
          </h3>
          
          <!-- Jog Controls -->
          <div class="card bg-base-300 p-3 mb-3">
            <p class="text-xs opacity-70 mb-2">XY Jog (mm)</p>
            <div class="grid grid-cols-3 gap-1">
              <div></div>
              <button class="btn btn-sm btn-ghost" data-jog-mm="Y:+">‚Üë</button>
              <div></div>
              <button class="btn btn-sm btn-ghost" data-jog-mm="X:-">‚Üê</button>
              <button class="btn btn-sm btn-primary btn-xs" id="btn-stop">‚¨§</button>
              <button class="btn btn-sm btn-ghost" data-jog-mm="X:+">‚Üí</button>
              <div></div>
              <button class="btn btn-sm btn-ghost" data-jog-mm="Y:-">‚Üì</button>
              <div></div>
            </div>
          </div>
          
          <!-- Z Jog -->
          <div class="card bg-base-300 p-3 mb-3">
            <p class="text-xs opacity-70 mb-2">Z Jog (mm)</p>
            <div class="flex gap-2 justify-center">
              <button class="btn btn-sm btn-ghost" data-jog-mm="Z:+">Z+</button>
              <button class="btn btn-sm btn-ghost" data-jog-mm="Z:-">Z-</button>
            </div>
          </div>
          
          <!-- Jog Step Size (mm) -->
          <div class="form-control">
            <label class="label">
              <span class="label-text text-xs">Step Size (mm)</span>
            </label>
            <select id="jog-step-mm" class="select select-bordered select-sm w-full">
              <option value="1">1 mm</option>
              <option value="5">5 mm</option>
              <option value="10" selected>10 mm</option>
              <option value="25">25 mm</option>
              <option value="50">50 mm</option>
            </select>
          </div>
        </div>
        
        <!-- Go To Position -->
        <div class="mb-4">
          <h3 class="font-bold text-lg mb-2">Go To Position (mm)</h3>
          <div class="grid grid-cols-3 gap-2 mb-2">
            <input type="number" id="goto-x" placeholder="X" class="input input-bordered input-sm" />
            <input type="number" id="goto-y" placeholder="Y" class="input input-bordered input-sm" />
            <input type="number" id="goto-z" placeholder="Z" class="input input-bordered input-sm" />
          </div>
          <button id="btn-goto" class="btn btn-primary btn-sm w-full">Go</button>
        </div>
        
        <!-- Tool Panel -->
        <div class="mb-4">
          <h3 class="font-bold text-lg mb-2 flex items-center gap-2">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
            AUX Tool
          </h3>
          <div id="tool-panel" class="card bg-base-300 p-3">
            <p class="text-sm opacity-70" id="tool-name">No tool connected</p>
            <div id="tool-commands" class="mt-2 space-y-1">
              <!-- Tool commands will be dynamically added here -->
            </div>
          </div>
        </div>
        
        <!-- Command Queue -->
        <div>
          <h3 class="font-bold text-lg mb-2 flex items-center gap-2">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16" />
            </svg>
            Command Queue
            <span class="badge badge-sm" id="queue-count">0</span>
          </h3>
          <div id="queue-list" class="bg-base-300 rounded-lg p-2 max-h-40 overflow-y-auto text-xs font-mono">
            <p class="opacity-50">No commands in queue</p>
          </div>
        </div>
        
      </div>
    </div>
  </div>
  
  <!-- Calibration Modal -->
  <dialog id="calibration-modal" class="modal">
    <div class="modal-box">
      <h3 class="font-bold text-lg">Calibration in Progress</h3>
      <p class="py-4">Please wait while the machine calibrates...</p>
      <progress class="progress progress-primary w-full" id="calibration-progress"></progress>
      <p class="text-sm opacity-70 mt-2" id="calibration-status">Finding home position...</p>
    </div>
  </dialog>

  <script>
    // ========================================
    // Global Variables
    // ========================================
    let controller = null;
    let graph = null;
    let graphCanvas = null;
    
    // Steps per 100mm settings (loaded from localStorage)
    const stepSettings = {
      m1: 1600, // Motor 1 (X)
      m2: 1600, // Motor 2 (Y)
      m3: 1600  // Motor 3 (Z)
    };
    
    // ========================================
    // Unit Conversion Functions
    // ========================================
    function mmToSteps(mm, motor) {
      const stepsPerMM = stepSettings[motor] / 100;
      return Math.round(mm * stepsPerMM);
    }
    
    function stepsToMM(steps, motor) {
      const stepsPerMM = stepSettings[motor] / 100;
      return steps / stepsPerMM;
    }
    
    function loadStepSettings() {
      const saved = localStorage.getItem('brionette_step_settings');
      if (saved) {
        const parsed = JSON.parse(saved);
        stepSettings.m1 = parsed.m1 || 1600;
        stepSettings.m2 = parsed.m2 || 1600;
        stepSettings.m3 = parsed.m3 || 1600;
      }
      // Update UI
      document.getElementById('steps-per-100mm-m1').value = stepSettings.m1;
      document.getElementById('steps-per-100mm-m2').value = stepSettings.m2;
      document.getElementById('steps-per-100mm-m3').value = stepSettings.m3;
    }
    
    function saveStepSettings() {
      stepSettings.m1 = parseInt(document.getElementById('steps-per-100mm-m1').value) || 1600;
      stepSettings.m2 = parseInt(document.getElementById('steps-per-100mm-m2').value) || 1600;
      stepSettings.m3 = parseInt(document.getElementById('steps-per-100mm-m3').value) || 1600;
      localStorage.setItem('brionette_step_settings', JSON.stringify(stepSettings));
      addLog(`Step settings saved: X=${stepSettings.m1}, Y=${stepSettings.m2}, Z=${stepSettings.m3} steps/100mm`, 'info');
    }
    
    // ========================================
    // Bench Grid System
    // ========================================
    const benchSettings = {
      cellSize: 140, // mm per grid cell
      motorMax: { m1: 300, m2: 300, m3: 100 } // Max range in mm
    };
    
    // Component settings for 96 Tip Box, 96 Well Plate, and Reservoir
    const componentSettings = {
      tipBox96: {
        offsetX: 14.38,  // A1 offset from grid origin X (mm)
        offsetY: 11.24,  // A1 offset from grid origin Y (mm)
        spacingX: 9.0,   // Well spacing X (mm)
        spacingY: 9.0,   // Well spacing Y (mm)
        zPosition: 50    // Z position to reach tips (mm)
      },
      wellPlate96: {
        offsetX: 14.38,
        offsetY: 11.24,
        spacingX: 9.0,
        spacingY: 9.0,
        zPosition: 30    // Z position to reach wells (mm)
      },
      reservoir: {
        offsetX: 50,     // Center offset X from grid origin (mm)
        offsetY: 40,     // Center offset Y from grid origin (mm)
        zPosition: 20    // Z position to reach liquid (mm)
      }
    };
    
    let currentSettingsType = null; // For modal
    
    let benchGrid = {
      cols: 0,
      rows: 0,
      cells: [] // Array of { col, row, component: null or { type, node } }
    };
    
    let selectedGridCell = null;
    
    function loadBenchSettings() {
      const saved = localStorage.getItem('brionette_bench_settings');
      if (saved) {
        const parsed = JSON.parse(saved);
        benchSettings.cellSize = parsed.cellSize || 140;
        benchSettings.motorMax = parsed.motorMax || { m1: 300, m2: 300, m3: 100 };
      }
      // Update UI if elements exist
      const cellSizeEl = document.getElementById('bench-cell-size');
      if (cellSizeEl) cellSizeEl.value = benchSettings.cellSize;
      
      const maxM1 = document.getElementById('motor-max-m1');
      const maxM2 = document.getElementById('motor-max-m2');
      const maxM3 = document.getElementById('motor-max-m3');
      if (maxM1) maxM1.value = benchSettings.motorMax.m1;
      if (maxM2) maxM2.value = benchSettings.motorMax.m2;
      if (maxM3) maxM3.value = benchSettings.motorMax.m3;
    }
    
    function saveBenchSettings() {
      benchSettings.cellSize = parseInt(document.getElementById('bench-cell-size').value) || 140;
      benchSettings.motorMax.m1 = parseInt(document.getElementById('motor-max-m1').value) || 300;
      benchSettings.motorMax.m2 = parseInt(document.getElementById('motor-max-m2').value) || 300;
      benchSettings.motorMax.m3 = parseInt(document.getElementById('motor-max-m3').value) || 100;
      localStorage.setItem('brionette_bench_settings', JSON.stringify(benchSettings));
      addLog(`Bench settings saved: Cell=${benchSettings.cellSize}mm, Max X=${benchSettings.motorMax.m1}, Y=${benchSettings.motorMax.m2}, Z=${benchSettings.motorMax.m3}`, 'info');
    }
    
    function loadComponentSettings() {
      const saved = localStorage.getItem('brionette_component_settings');
      if (saved) {
        const parsed = JSON.parse(saved);
        if (parsed.tipBox96) Object.assign(componentSettings.tipBox96, parsed.tipBox96);
        if (parsed.wellPlate96) Object.assign(componentSettings.wellPlate96, parsed.wellPlate96);
        if (parsed.reservoir) Object.assign(componentSettings.reservoir, parsed.reservoir);
      }
    }
    
    function openComponentSettings(type) {
      currentSettingsType = type;
      const modal = document.getElementById('component-settings-modal');
      const title = document.getElementById('component-settings-title');
      const content = document.getElementById('component-settings-content');
      
      let html = '';
      
      if (type === 'tipBox96') {
        title.textContent = 'üß™ 96 Tip Box Settings';
        const s = componentSettings.tipBox96;
        html = `
          <fieldset class="fieldset bg-base-200 p-4 rounded-lg">
            <legend class="fieldset-legend">Position Offsets (A1 from grid origin)</legend>
            <div class="grid grid-cols-2 gap-3">
              <div class="form-control">
                <label class="label"><span class="label-text">Offset X (mm)</span></label>
                <input type="number" id="settings-offset-x" class="input input-bordered" value="${s.offsetX}" step="0.01" />
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text">Offset Y (mm)</span></label>
                <input type="number" id="settings-offset-y" class="input input-bordered" value="${s.offsetY}" step="0.01" />
              </div>
            </div>
          </fieldset>
          <fieldset class="fieldset bg-base-200 p-4 rounded-lg mt-4">
            <legend class="fieldset-legend">Well Spacing</legend>
            <div class="grid grid-cols-2 gap-3">
              <div class="form-control">
                <label class="label"><span class="label-text">Spacing X (mm)</span></label>
                <input type="number" id="settings-spacing-x" class="input input-bordered" value="${s.spacingX}" step="0.01" />
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text">Spacing Y (mm)</span></label>
                <input type="number" id="settings-spacing-y" class="input input-bordered" value="${s.spacingY}" step="0.01" />
              </div>
            </div>
          </fieldset>
          <fieldset class="fieldset bg-base-200 p-4 rounded-lg mt-4">
            <legend class="fieldset-legend">Z Position</legend>
            <div class="form-control">
              <label class="label"><span class="label-text">Z Position (mm)</span></label>
              <input type="number" id="settings-z-pos" class="input input-bordered" value="${s.zPosition}" step="0.1" />
              <p class="label text-xs opacity-70">Height to reach the tips</p>
            </div>
          </fieldset>
        `;
      } else if (type === 'wellPlate96') {
        title.textContent = 'üß´ 96 Well Plate Settings';
        const s = componentSettings.wellPlate96;
        html = `
          <fieldset class="fieldset bg-base-200 p-4 rounded-lg">
            <legend class="fieldset-legend">Position Offsets (A1 from grid origin)</legend>
            <div class="grid grid-cols-2 gap-3">
              <div class="form-control">
                <label class="label"><span class="label-text">Offset X (mm)</span></label>
                <input type="number" id="settings-offset-x" class="input input-bordered" value="${s.offsetX}" step="0.01" />
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text">Offset Y (mm)</span></label>
                <input type="number" id="settings-offset-y" class="input input-bordered" value="${s.offsetY}" step="0.01" />
              </div>
            </div>
          </fieldset>
          <fieldset class="fieldset bg-base-200 p-4 rounded-lg mt-4">
            <legend class="fieldset-legend">Well Spacing</legend>
            <div class="grid grid-cols-2 gap-3">
              <div class="form-control">
                <label class="label"><span class="label-text">Spacing X (mm)</span></label>
                <input type="number" id="settings-spacing-x" class="input input-bordered" value="${s.spacingX}" step="0.01" />
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text">Spacing Y (mm)</span></label>
                <input type="number" id="settings-spacing-y" class="input input-bordered" value="${s.spacingY}" step="0.01" />
              </div>
            </div>
          </fieldset>
          <fieldset class="fieldset bg-base-200 p-4 rounded-lg mt-4">
            <legend class="fieldset-legend">Z Position</legend>
            <div class="form-control">
              <label class="label"><span class="label-text">Z Position (mm)</span></label>
              <input type="number" id="settings-z-pos" class="input input-bordered" value="${s.zPosition}" step="0.1" />
              <p class="label text-xs opacity-70">Height to reach the wells</p>
            </div>
          </fieldset>
        `;
      } else if (type === 'reservoir') {
        title.textContent = 'ü´ó Reservoir Settings';
        const s = componentSettings.reservoir;
        html = `
          <fieldset class="fieldset bg-base-200 p-4 rounded-lg">
            <legend class="fieldset-legend">Position Offsets (from grid origin)</legend>
            <div class="grid grid-cols-2 gap-3">
              <div class="form-control">
                <label class="label"><span class="label-text">Offset X (mm)</span></label>
                <input type="number" id="settings-offset-x" class="input input-bordered" value="${s.offsetX}" step="0.01" />
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text">Offset Y (mm)</span></label>
                <input type="number" id="settings-offset-y" class="input input-bordered" value="${s.offsetY}" step="0.01" />
              </div>
            </div>
          </fieldset>
          <fieldset class="fieldset bg-base-200 p-4 rounded-lg mt-4">
            <legend class="fieldset-legend">Z Position</legend>
            <div class="form-control">
              <label class="label"><span class="label-text">Z Position (mm)</span></label>
              <input type="number" id="settings-z-pos" class="input input-bordered" value="${s.zPosition}" step="0.1" />
              <p class="label text-xs opacity-70">Height to reach the liquid</p>
            </div>
          </fieldset>
        `;
      }
      
      content.innerHTML = html;
      modal.showModal();
    }
    
    function saveComponentSettingsFromModal() {
      if (!currentSettingsType) return;
      
      const offsetX = parseFloat(document.getElementById('settings-offset-x')?.value) || 0;
      const offsetY = parseFloat(document.getElementById('settings-offset-y')?.value) || 0;
      const zPos = parseFloat(document.getElementById('settings-z-pos')?.value) || 0;
      
      if (currentSettingsType === 'tipBox96') {
        componentSettings.tipBox96.offsetX = offsetX;
        componentSettings.tipBox96.offsetY = offsetY;
        componentSettings.tipBox96.spacingX = parseFloat(document.getElementById('settings-spacing-x')?.value) || 9.0;
        componentSettings.tipBox96.spacingY = parseFloat(document.getElementById('settings-spacing-y')?.value) || 9.0;
        componentSettings.tipBox96.zPosition = zPos;
      } else if (currentSettingsType === 'wellPlate96') {
        componentSettings.wellPlate96.offsetX = offsetX;
        componentSettings.wellPlate96.offsetY = offsetY;
        componentSettings.wellPlate96.spacingX = parseFloat(document.getElementById('settings-spacing-x')?.value) || 9.0;
        componentSettings.wellPlate96.spacingY = parseFloat(document.getElementById('settings-spacing-y')?.value) || 9.0;
        componentSettings.wellPlate96.zPosition = zPos;
      } else if (currentSettingsType === 'reservoir') {
        componentSettings.reservoir.offsetX = offsetX;
        componentSettings.reservoir.offsetY = offsetY;
        componentSettings.reservoir.zPosition = zPos;
      }
      
      localStorage.setItem('brionette_component_settings', JSON.stringify(componentSettings));
      addLog(`${currentSettingsType} settings saved`, 'info');
      document.getElementById('component-settings-modal').close();
    }

    function createBenchGrid() {
      const cols = parseInt(document.getElementById('bench-cols').value) || 3;
      const rows = parseInt(document.getElementById('bench-rows').value) || 2;
      
      benchGrid.cols = cols;
      benchGrid.rows = rows;
      benchGrid.cells = [];
      
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          benchGrid.cells.push({
            col: c,
            row: r,
            component: null
          });
        }
      }
      
      renderBenchGrid();
      addLog(`Created bench grid: ${cols}x${rows} (${cols * rows} cells, ${benchSettings.cellSize}mm each)`, 'info');
    }
    
    function renderBenchGrid() {
      const container = document.getElementById('bench-grid-container');
      container.style.gridTemplateColumns = `repeat(${benchGrid.cols}, 1fr)`;
      
      container.innerHTML = benchGrid.cells.map((cell, idx) => {
        const posX = cell.col * benchSettings.cellSize;
        const posY = cell.row * benchSettings.cellSize;
        const hasComponent = cell.component !== null;
        
        return `
          <div class="bench-cell aspect-square bg-base-100 border-2 ${hasComponent ? 'border-primary' : 'border-base-content/20'} rounded-lg p-2 cursor-pointer hover:border-primary/50 transition-all flex flex-col"
               data-cell-idx="${idx}" data-pos-x="${posX}" data-pos-y="${posY}">
            <div class="text-xs opacity-50">${String.fromCharCode(65 + cell.row)}${cell.col + 1}</div>
            <div class="text-xs opacity-30">(${posX}, ${posY})</div>
            <div class="flex-1 flex items-center justify-center">
              ${hasComponent ? `
                <div class="text-center">
                  <div class="text-sm font-bold">${getComponentName(cell.component.type)}</div>
                  <button class="btn btn-xs btn-ghost mt-1" onclick="addComponentToCanvas(${idx})">‚Üí Canvas</button>
                </div>
              ` : `
                <div class="text-2xl opacity-20">+</div>
              `}
            </div>
          </div>
        `;
      }).join('');
      
      // Add click handlers
      container.querySelectorAll('.bench-cell').forEach(el => {
        el.addEventListener('click', (e) => {
          if (e.target.closest('button')) return; // Don't trigger on button click
          const idx = parseInt(el.dataset.cellIdx);
          selectGridCell(idx);
        });
      });
    }
    
    function getComponentName(type) {
      const names = {
        'tip-box-96': '96 Tips',
        'wellplate-96': '96 Plate',
        'reservoir': 'Reservoir'
      };
      return names[type] || type;
    }
    
    function selectGridCell(idx) {
      selectedGridCell = idx;
      const cell = benchGrid.cells[idx];
      
      // Highlight selected cell
      document.querySelectorAll('.bench-cell').forEach((el, i) => {
        el.classList.toggle('ring-2', i === idx);
        el.classList.toggle('ring-primary', i === idx);
      });
      
      // Show component selection if empty
      if (!cell.component) {
        // Highlight component list items
        document.querySelectorAll('.component-item').forEach(item => {
          item.classList.add('animate-pulse');
        });
        setTimeout(() => {
          document.querySelectorAll('.component-item').forEach(item => {
            item.classList.remove('animate-pulse');
          });
        }, 1000);
      }
    }
    
    function assignComponentToCell(componentType) {
      if (selectedGridCell === null) {
        alert('Please select a grid cell first');
        return;
      }
      
      const cell = benchGrid.cells[selectedGridCell];
      cell.component = { type: componentType, node: null };
      
      renderBenchGrid();
      addLog(`Assigned ${getComponentName(componentType)} to cell ${String.fromCharCode(65 + cell.row)}${cell.col + 1}`, 'info');
    }
    
    function addComponentToCanvas(cellIdx) {
      const cell = benchGrid.cells[cellIdx];
      if (!cell.component) return;
      
      const posX = cell.col * benchSettings.cellSize;
      const posY = cell.row * benchSettings.cellSize;
      
      // Create node based on component type
      let node = null;
      let nodeType = '';
      
      if (cell.component.type === 'tip-box-96') {
        nodeType = 'bench/tip-box-96';
      } else if (cell.component.type === 'wellplate-96') {
        nodeType = 'bench/wellplate-96';
      } else if (cell.component.type === 'reservoir') {
        nodeType = 'bench/reservoir';
      }
      
      if (nodeType) {
        node = LiteGraph.createNode(nodeType);
        if (node) {
          node.properties.gridX = posX;
          node.properties.gridY = posY;
        }
      }
      
      if (node) {
        // Position on canvas
        node.pos = [400, 200];
        graph.add(node);
        graphCanvas.setDirty(true, true);
        
        cell.component.node = node;
        addLog(`Added ${getComponentName(cell.component.type)} to canvas at grid position (${posX}, ${posY})mm`, 'info');
      }
    }
    
    // ========================================
    // Initialize on DOM Load
    // ========================================
    document.addEventListener('DOMContentLoaded', () => {
      loadStepSettings();
      loadBenchSettings();
      loadComponentSettings();
      initMotorController();
      initLiteGraph();
      initUIEvents();
      initDragDrop();
      initBenchTools();
      initSetupWizard();
      initSimulator();
      initSaveLoad();
      
      // Check if first run or needs setup
      checkAndShowSetupWizard();
    });

    function initBenchTools() {
      // Create grid button
      document.getElementById('btn-create-grid')?.addEventListener('click', createBenchGrid);
      
      // Component settings modal save button
      document.getElementById('btn-save-component-settings')?.addEventListener('click', saveComponentSettingsFromModal);
      
      // Component selection
      document.querySelectorAll('.component-item').forEach(item => {
        item.addEventListener('click', () => {
          const componentType = item.dataset.component;
          assignComponentToCell(componentType);
        });
      });
      
      // Save bench settings
      document.getElementById('btn-save-bench-settings')?.addEventListener('click', saveBenchSettings);
      document.getElementById('btn-save-motor-max')?.addEventListener('click', saveBenchSettings);
    }
    
    // ========================================
    // Motor Controller Setup
    // ========================================
    function initMotorController() {
      controller = new MotorController();
      
      // Handle incoming data
      controller.onData = (data) => {
        handleMotorData(data);
      };
      
      // Handle raw data for logging
      controller.onRawData = (raw) => {
        addLog(raw, 'info');
      };
      
      // Handle queue updates
      controller.onQueueUpdate = (action, item) => {
        updateQueueDisplay(action, item);
      };
      
      // Handle tool updates
      controller.onToolUpdate = (name, commands) => {
        updateToolPanel(name, commands);
      };
    }
    
    // ========================================
    // LiteGraph.js Setup
    // ========================================
    function initLiteGraph() {
      // Register custom nodes
      registerMotorNodes();
      
      // Create graph
      graph = new LGraph();
      
      // Create canvas
      const canvas = document.getElementById('graph-canvas');
      graphCanvas = new LGraphCanvas(canvas, graph);
      
      // Configure canvas
      graphCanvas.background_image = null;
      graphCanvas.render_shadows = false;
      graphCanvas.clear_background = true;
      
      // Resize handler
      function resizeCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        graphCanvas.resize();
      }
      
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // Start graph
      graph.start();
      
      // Add some default nodes
      addDefaultNodes();
    }
    
    // ========================================
    // Custom LiteGraph Nodes for Motor Control
    // ========================================
    function registerMotorNodes() {
      
      // ===== Motor Move Node (mm) =====
      function MotorMoveNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addInput("X (mm)", "number");
        this.addInput("Y (mm)", "number");
        this.addInput("Z (mm)", "number");
        this.addOutput("Done", LiteGraph.EVENT);
        this.properties = { x: 0, y: 0, z: 0 };
        this.addWidget("number", "X (mm)", 0, (v) => { this.properties.x = v; });
        this.addWidget("number", "Y (mm)", 0, (v) => { this.properties.y = v; });
        this.addWidget("number", "Z (mm)", 0, (v) => { this.properties.z = v; });
        this.size = [180, 130];
      }
      MotorMoveNode.title = "Move Motors (mm)";
      MotorMoveNode.desc = "Move all motors to absolute position in millimeters";
      MotorMoveNode.prototype.onAction = async function(action, param) {
        if (!controller || !controller.isConnected) return;
        
        const xMM = this.getInputData(1) ?? this.properties.x;
        const yMM = this.getInputData(2) ?? this.properties.y;
        const zMM = this.getInputData(3) ?? this.properties.z;
        
        // Convert mm to steps
        const xSteps = mmToSteps(xMM, 'm1');
        const ySteps = mmToSteps(yMM, 'm2');
        const zSteps = mmToSteps(zMM, 'm3');
        
        try {
          await controller.moveAll(xSteps, ySteps, zSteps);
          this.triggerSlot(0); // Trigger Done
        } catch (e) {
          console.error("Move error:", e);
        }
      };
      LiteGraph.registerNodeType("motor/move", MotorMoveNode);
      
      // ===== Motor Move XY Node (mm) =====
      function MotorMoveXYNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addInput("X (mm)", "number");
        this.addInput("Y (mm)", "number");
        this.addOutput("Done", LiteGraph.EVENT);
        this.properties = { x: 0, y: 0 };
        this.addWidget("number", "X (mm)", 0, (v) => { this.properties.x = v; });
        this.addWidget("number", "Y (mm)", 0, (v) => { this.properties.y = v; });
      }
      MotorMoveXYNode.title = "Move XY (mm)";
      MotorMoveXYNode.desc = "Move X and Y motors to absolute position in millimeters";
      MotorMoveXYNode.prototype.onAction = async function(action, param) {
        if (!controller || !controller.isConnected) return;
        
        const xMM = this.getInputData(1) ?? this.properties.x;
        const yMM = this.getInputData(2) ?? this.properties.y;
        
        // Convert mm to steps
        const xSteps = mmToSteps(xMM, 'm1');
        const ySteps = mmToSteps(yMM, 'm2');
        
        try {
          // Send X and Y commands
          await controller.send(`M1:G${xSteps}`);
          await controller.send(`M2:G${ySteps}`);
          this.triggerSlot(0); // Trigger Done
        } catch (e) {
          console.error("Move XY error:", e);
        }
      };
      LiteGraph.registerNodeType("motor/move_xy", MotorMoveXYNode);
      
      // ===== Motor Position Node (mm) =====
      function MotorPositionNode() {
        this.addOutput("X (mm)", "number");
        this.addOutput("Y (mm)", "number");
        this.addOutput("Z (mm)", "number");
        this.size = [140, 80];
      }
      MotorPositionNode.title = "Motor Position (mm)";
      MotorPositionNode.desc = "Get current motor positions in millimeters";
      MotorPositionNode.prototype.onExecute = function() {
        if (!controller) return;
        
        const m1Steps = controller.motorStates.Motor1?.position ?? 0;
        const m2Steps = controller.motorStates.Motor2?.position ?? 0;
        const m3Steps = controller.motorStates.Motor3?.position ?? 0;
        
        // Convert steps to mm
        this.setOutputData(0, stepsToMM(m1Steps, 'm1'));
        this.setOutputData(1, stepsToMM(m2Steps, 'm2'));
        this.setOutputData(2, stepsToMM(m3Steps, 'm3'));
      };
      LiteGraph.registerNodeType("motor/position", MotorPositionNode);
      
      // ===== Stop Node =====
      function MotorStopNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Stopped", LiteGraph.EVENT);
        this.size = [100, 50];
        this.color = "#f38ba8";
      }
      MotorStopNode.title = "STOP";
      MotorStopNode.desc = "Stop all motors";
      MotorStopNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        await controller.stop();
        this.triggerSlot(0);
      };
      LiteGraph.registerNodeType("motor/stop", MotorStopNode);
      
      // ===== Wait for Idle Node =====
      function WaitIdleNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Idle", LiteGraph.EVENT);
        this.size = [140, 50];
      }
      WaitIdleNode.title = "Wait Idle";
      WaitIdleNode.desc = "Wait until all motors are idle";
      WaitIdleNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        await controller.waitForIdle();
        this.triggerSlot(0);
      };
      LiteGraph.registerNodeType("motor/wait_idle", WaitIdleNode);
      
      // ===== Set Home Node =====
      function SetHomeNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Done", LiteGraph.EVENT);
        this.size = [120, 50];
      }
      SetHomeNode.title = "Set Home";
      SetHomeNode.desc = "Set current position as home (0,0,0)";
      SetHomeNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        await controller.setHome();
        this.triggerSlot(0);
      };
      LiteGraph.registerNodeType("motor/set_home", SetHomeNode);
      
      // ===== Delay Node =====
      function DelayNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Done", LiteGraph.EVENT);
        this.properties = { delay: 1000 };
        this.addWidget("number", "Delay (ms)", 1000, (v) => { this.properties.delay = v; });
      }
      DelayNode.title = "Delay";
      DelayNode.desc = "Wait for specified time";
      DelayNode.prototype.onAction = function() {
        setTimeout(() => {
          this.triggerSlot(0);
        }, this.properties.delay);
      };
      LiteGraph.registerNodeType("util/delay", DelayNode);
      
      // ===== Button Node =====
      function ButtonNode() {
        this.addOutput("Click", LiteGraph.EVENT);
        this.size = [100, 50];
        this.properties = { label: "RUN" };
        this.addWidget("button", "RUN", null, () => {
          this.triggerSlot(0);
        });
      }
      ButtonNode.title = "Button";
      ButtonNode.desc = "Manual trigger button";
      LiteGraph.registerNodeType("util/button", ButtonNode);
      
      // ===== Number Node =====
      function NumberNode() {
        this.addOutput("Value", "number");
        this.properties = { value: 0 };
        this.addWidget("number", "Value", 0, (v) => { 
          this.properties.value = v; 
        });
      }
      NumberNode.title = "Number";
      NumberNode.desc = "Output a number value";
      NumberNode.prototype.onExecute = function() {
        this.setOutputData(0, this.properties.value);
      };
      LiteGraph.registerNodeType("util/number", NumberNode);
      
      // ===== AUX Command Node =====
      function AuxCommandNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Done", LiteGraph.EVENT);
        this.properties = { command: "" };
        this.addWidget("text", "Command", "", (v) => { this.properties.command = v; });
      }
      AuxCommandNode.title = "AUX Command";
      AuxCommandNode.desc = "Send command to AUX tool";
      AuxCommandNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        const cmd = this.properties.command;
        if (cmd) {
          await controller.sendImmediate(`m${cmd}`);
          this.triggerSlot(0);
        }
      };
      LiteGraph.registerNodeType("motor/aux_command", AuxCommandNode);
      
      // ===== Sequence Node =====
      function SequenceNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("1", LiteGraph.EVENT);
        this.addOutput("2", LiteGraph.EVENT);
        this.addOutput("3", LiteGraph.EVENT);
        this.addOutput("4", LiteGraph.EVENT);
        this.size = [100, 100];
      }
      SequenceNode.title = "Sequence";
      SequenceNode.desc = "Trigger outputs in sequence";
      SequenceNode.prototype.onAction = function() {
        // Trigger all outputs in sequence
        for (let i = 0; i < 4; i++) {
          this.triggerSlot(i);
        }
      };
      LiteGraph.registerNodeType("util/sequence", SequenceNode);
      
      // ===== Loop Node =====
      function LoopNode() {
        this.addInput("Start", LiteGraph.ACTION);
        this.addInput("Next", LiteGraph.ACTION);
        this.addOutput("Loop", LiteGraph.EVENT);
        this.addOutput("Done", LiteGraph.EVENT);
        this.addOutput("Value", "number");
        this.properties = { min: 0, max: 10, current: 0, running: false };
        this.addWidget("number", "Min", 0, (v) => { this.properties.min = v; });
        this.addWidget("number", "Max", 10, (v) => { this.properties.max = v; });
        this.size = [160, 120];
        this.color = "#a6e3a1";
      }
      LoopNode.title = "Loop";
      LoopNode.desc = "Loop from min to max, triggered by Start or Next";
      LoopNode.prototype.onAction = function(action, param) {
        if (action === "Start") {
          // Reset and start loop
          this.properties.current = this.properties.min;
          this.properties.running = true;
          this.setOutputData(2, this.properties.current);
          this.triggerSlot(0); // Trigger Loop
        } else if (action === "Next") {
          if (!this.properties.running) return;
          
          // Increment
          this.properties.current++;
          
          if (this.properties.current <= this.properties.max) {
            // Continue loop
            this.setOutputData(2, this.properties.current);
            this.triggerSlot(0); // Trigger Loop
          } else {
            // Done
            this.properties.running = false;
            this.triggerSlot(1); // Trigger Done
          }
        }
      };
      LoopNode.prototype.onExecute = function() {
        this.setOutputData(2, this.properties.current);
      };
      LiteGraph.registerNodeType("util/loop", LoopNode);
      
      // ===== Move Single Motor Node (mm) =====
      function MoveSingleNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addInput("Position (mm)", "number");
        this.addOutput("Done", LiteGraph.EVENT);
        this.properties = { motor: 1, position: 0 };
        this.addWidget("combo", "Motor", 1, (v) => { this.properties.motor = v; }, { values: [1, 2, 3] });
        this.addWidget("number", "Pos (mm)", 0, (v) => { this.properties.position = v; });
        this.size = [170, 100];
      }
      MoveSingleNode.title = "Move Motor (mm)";
      MoveSingleNode.desc = "Move a single motor to position in millimeters";
      MoveSingleNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        const posMM = this.getInputData(1) ?? this.properties.position;
        const motorKey = `m${this.properties.motor}`;
        const posSteps = mmToSteps(posMM, motorKey);
        const cmd = `M${this.properties.motor}:G${posSteps}`;
        await controller.send(cmd);
        this.triggerSlot(0);
      };
      LiteGraph.registerNodeType("motor/move_single", MoveSingleNode);
      
      // ===== Relative Move Node (mm) =====
      function RelativeMoveNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addInput("Distance (mm)", "number");
        this.addOutput("Done", LiteGraph.EVENT);
        this.properties = { motor: 1, distance: 10 };
        this.addWidget("combo", "Motor", 1, (v) => { this.properties.motor = v; }, { values: [1, 2, 3] });
        this.addWidget("number", "Dist (mm)", 10, (v) => { this.properties.distance = v; });
        this.size = [170, 100];
      }
      RelativeMoveNode.title = "Relative Move (mm)";
      RelativeMoveNode.desc = "Move motor relative to current position in millimeters";
      RelativeMoveNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        const distMM = this.getInputData(1) ?? this.properties.distance;
        const motorKey = `m${this.properties.motor}`;
        const distSteps = mmToSteps(Math.abs(distMM), motorKey);
        const sign = distMM >= 0 ? 'F' : 'B';
        const cmd = `M${this.properties.motor}:${sign}${distSteps}`;
        await controller.send(cmd);
        this.triggerSlot(0);
      };
      LiteGraph.registerNodeType("motor/move_relative", RelativeMoveNode);
      
      // ===== Emergency Stop Node =====
      function EmergencyStopNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Stopped", LiteGraph.EVENT);
        this.size = [120, 50];
        this.color = "#f38ba8";
        this.bgcolor = "#45132a";
      }
      EmergencyStopNode.title = "E-STOP";
      EmergencyStopNode.desc = "Emergency stop all motors";
      EmergencyStopNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        await controller.emergencyStop();
        this.triggerSlot(0);
      };
      LiteGraph.registerNodeType("motor/emergency", EmergencyStopNode);
      
      // ===== Enable Motor Node =====
      function EnableMotorNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Done", LiteGraph.EVENT);
        this.properties = { motor: 0 }; // 0 = all
        this.addWidget("combo", "Motor", 0, (v) => { this.properties.motor = v; }, { values: [0, 1, 2, 3] });
        this.size = [140, 70];
      }
      EnableMotorNode.title = "Enable";
      EnableMotorNode.desc = "Enable motor(s)";
      EnableMotorNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        if (this.properties.motor === 0) {
          await controller.sendImmediate('E');
        } else {
          await controller.sendImmediate(`M${this.properties.motor}:E`);
        }
        this.triggerSlot(0);
      };
      LiteGraph.registerNodeType("motor/enable", EnableMotorNode);
      
      // ===== Disable Motor Node =====
      function DisableMotorNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Done", LiteGraph.EVENT);
        this.properties = { motor: 0 }; // 0 = all
        this.addWidget("combo", "Motor", 0, (v) => { this.properties.motor = v; }, { values: [0, 1, 2, 3] });
        this.size = [140, 70];
      }
      DisableMotorNode.title = "Disable";
      DisableMotorNode.desc = "Disable motor(s)";
      DisableMotorNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        if (this.properties.motor === 0) {
          await controller.sendImmediate('D');
        } else {
          await controller.sendImmediate(`M${this.properties.motor}:D`);
        }
        this.triggerSlot(0);
      };
      LiteGraph.registerNodeType("motor/disable", DisableMotorNode);
      
      // ===== Set Speed Node =====
      function SetSpeedNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addInput("Speed", "number");
        this.addOutput("Done", LiteGraph.EVENT);
        this.properties = { speed: 1000, motor: 0 };
        this.addWidget("combo", "Motor", 0, (v) => { this.properties.motor = v; }, { values: [0, 1, 2, 3] });
        this.addWidget("number", "Speed", 1000, (v) => { this.properties.speed = v; });
        this.size = [160, 100];
      }
      SetSpeedNode.title = "Set Speed";
      SetSpeedNode.desc = "Set motor speed";
      SetSpeedNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        const spd = this.getInputData(1) ?? this.properties.speed;
        if (this.properties.motor === 0) {
          await controller.setSpeed(spd);
        } else {
          await controller.sendImmediate(`M${this.properties.motor}:S${spd}`);
        }
        this.triggerSlot(0);
      };
      LiteGraph.registerNodeType("motor/set_speed", SetSpeedNode);
      
      // ===== Set Acceleration Node =====
      function SetAccelNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addInput("Accel", "number");
        this.addOutput("Done", LiteGraph.EVENT);
        this.properties = { accel: 500, motor: 0 };
        this.addWidget("combo", "Motor", 0, (v) => { this.properties.motor = v; }, { values: [0, 1, 2, 3] });
        this.addWidget("number", "Accel", 500, (v) => { this.properties.accel = v; });
        this.size = [160, 100];
      }
      SetAccelNode.title = "Set Accel";
      SetAccelNode.desc = "Set motor acceleration";
      SetAccelNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        const acc = this.getInputData(1) ?? this.properties.accel;
        if (this.properties.motor === 0) {
          await controller.setAcceleration(acc);
        } else {
          await controller.sendImmediate(`M${this.properties.motor}:A${acc}`);
        }
        this.triggerSlot(0);
      };
      LiteGraph.registerNodeType("motor/set_accel", SetAccelNode);
      
      // ===== Calibrate Node =====
      function CalibrateNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Done", LiteGraph.EVENT);
        this.addOutput("X Size", "number");
        this.addOutput("Y Size", "number");
        this.addOutput("Z Size", "number");
        this.size = [140, 100];
      }
      CalibrateNode.title = "Calibrate";
      CalibrateNode.desc = "Run calibration sequence";
      CalibrateNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        try {
          const result = await controller.calibration();
          this.setOutputData(1, result.motor1);
          this.setOutputData(2, result.motor2);
          this.setOutputData(3, result.motor3);
          this.triggerSlot(0);
        } catch (e) {
          console.error("Calibration error:", e);
        }
      };
      LiteGraph.registerNodeType("motor/calibrate", CalibrateNode);
      
      // ===== Motor Status Node =====
      function MotorStatusNode() {
        this.addOutput("M1 Status", "string");
        this.addOutput("M2 Status", "string");
        this.addOutput("M3 Status", "string");
        this.size = [130, 80];
      }
      MotorStatusNode.title = "Motor Status";
      MotorStatusNode.desc = "Get motor status";
      MotorStatusNode.prototype.onExecute = function() {
        if (!controller) return;
        this.setOutputData(0, controller.motorStates.Motor1?.status ?? "UNKNOWN");
        this.setOutputData(1, controller.motorStates.Motor2?.status ?? "UNKNOWN");
        this.setOutputData(2, controller.motorStates.Motor3?.status ?? "UNKNOWN");
      };
      LiteGraph.registerNodeType("motor/status", MotorStatusNode);
      
      // ===== Limit Switch Node =====
      function LimitSwitchNode() {
        this.addOutput("M1 Min", "boolean");
        this.addOutput("M1 Max", "boolean");
        this.addOutput("M2 Min", "boolean");
        this.addOutput("M2 Max", "boolean");
        this.addOutput("M3 Min", "boolean");
        this.addOutput("M3 Max", "boolean");
        this.size = [130, 140];
      }
      LimitSwitchNode.title = "Limit Switches";
      LimitSwitchNode.desc = "Get limit switch status";
      LimitSwitchNode.prototype.onExecute = function() {
        if (!controller) return;
        this.setOutputData(0, controller.motorStates.Motor1?.limitMin ?? false);
        this.setOutputData(1, controller.motorStates.Motor1?.limitMax ?? false);
        this.setOutputData(2, controller.motorStates.Motor2?.limitMin ?? false);
        this.setOutputData(3, controller.motorStates.Motor2?.limitMax ?? false);
        this.setOutputData(4, controller.motorStates.Motor3?.limitMin ?? false);
        this.setOutputData(5, controller.motorStates.Motor3?.limitMax ?? false);
      };
      LiteGraph.registerNodeType("motor/limit", LimitSwitchNode);
      
      // ===== AUX Query Tool Node =====
      function AuxQueryToolNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Done", LiteGraph.EVENT);
        this.addOutput("Tool Name", "string");
        this.size = [150, 70];
      }
      AuxQueryToolNode.title = "Query Tool";
      AuxQueryToolNode.desc = "Query connected AUX tool";
      AuxQueryToolNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        const result = await controller.queryToolCommands();
        this.setOutputData(1, result?.name ?? "None");
        this.triggerSlot(0);
      };
      LiteGraph.registerNodeType("motor/aux_query", AuxQueryToolNode);
      
      // ===== Comment Node =====
      function CommentNode() {
        this.properties = { text: "Comment" };
        this.size = [200, 60];
        this.addWidget("text", "Text", "Comment", (v) => { this.properties.text = v; });
        this.color = "#94a3b8";
        this.bgcolor = "#1e293b";
      }
      CommentNode.title = "Comment";
      CommentNode.desc = "Add a comment/note";
      LiteGraph.registerNodeType("util/comment", CommentNode);
      
      // ========================================
      // Pipette Module Nodes (P200 Syringe)
      // ========================================
      
      // ===== Pipette Calibrate Node =====
      function PipetteCalibrateNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Next", LiteGraph.EVENT);
        this.size = [180, 30];
        this.color = "#f9a825";
        this.bgcolor = "#5d4037";
      }
      PipetteCalibrateNode.title = "Calibrate (Auto Home)";
      PipetteCalibrateNode.desc = "Calibrate pipette to home position";
      PipetteCalibrateNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        try {
          await controller.executeToolCommand({ cmd: 'c', isQueue: true });
          this.triggerSlot(0);
        } catch (e) {
          console.error("Pipette calibrate error:", e);
        }
      };
      LiteGraph.registerNodeType("pipette/calibrate", PipetteCalibrateNode);
      
      // ===== Pipette Aspirate Node =====
      function PipetteAspirateNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addInput("Volume (¬µL)", "number");
        this.addOutput("Next", LiteGraph.EVENT);
        this.properties = { volume: 100 };
        this.addWidget("number", "Volume", this.properties.volume, (v) => { 
          this.properties.volume = Math.max(0, Math.min(200, v)); 
        }, { min: 0, max: 200 });
        this.size = [180, 60];
        this.color = "#4fc3f7";
        this.bgcolor = "#01579b";
      }
      PipetteAspirateNode.title = "Aspirate";
      PipetteAspirateNode.desc = "Aspirate x ¬µL";
      PipetteAspirateNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        const vol = this.getInputData(1) ?? this.properties.volume;
        try {
          await controller.executeToolCommand({ cmd: 'u', inputType: 'float', isQueue: true }, vol);
          this.triggerSlot(0);
        } catch (e) {
          console.error("Pipette aspirate error:", e);
        }
      };
      LiteGraph.registerNodeType("pipette/aspirate", PipetteAspirateNode);
      
      // ===== Pipette Blowout Node =====
      function PipetteBlowoutNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Next", LiteGraph.EVENT);
        this.size = [180, 30];
        this.color = "#ff7043";
        this.bgcolor = "#bf360c";
      }
      PipetteBlowoutNode.title = "Blowout Sequence";
      PipetteBlowoutNode.desc = "Perform blowout sequence";
      PipetteBlowoutNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        try {
          await controller.executeToolCommand({ cmd: 'b', isQueue: true });
          this.triggerSlot(0);
        } catch (e) {
          console.error("Pipette blowout error:", e);
        }
      };
      LiteGraph.registerNodeType("pipette/blowout", PipetteBlowoutNode);
      
      // ===== Pipette Tip Dispense Node =====
      function PipetteTipDispenseNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Next", LiteGraph.EVENT);
        this.size = [180, 30];
        this.color = "#ab47bc";
        this.bgcolor = "#4a148c";
      }
      PipetteTipDispenseNode.title = "Tip Dispense Sequence";
      PipetteTipDispenseNode.desc = "Perform tip dispense sequence";
      PipetteTipDispenseNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        try {
          await controller.executeToolCommand({ cmd: 'k', isQueue: true });
          this.triggerSlot(0);
        } catch (e) {
          console.error("Pipette tip dispense error:", e);
        }
      };
      LiteGraph.registerNodeType("pipette/tip_dispense", PipetteTipDispenseNode);
      
      // ===== Pipette Go to Default Position Node =====
      function PipetteDefaultPosNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Next", LiteGraph.EVENT);
        this.size = [180, 30];
        this.color = "#66bb6a";
        this.bgcolor = "#1b5e20";
      }
      PipetteDefaultPosNode.title = "Go to Default Position";
      PipetteDefaultPosNode.desc = "Move to default ready position";
      PipetteDefaultPosNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        try {
          await controller.executeToolCommand({ cmd: 'u', isQueue: true });
          this.triggerSlot(0);
        } catch (e) {
          console.error("Pipette default pos error:", e);
        }
      };
      LiteGraph.registerNodeType("pipette/default_pos", PipetteDefaultPosNode);
      
      // ===== Pipette Set Acceleration Node =====
      function PipetteSetAccelNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addInput("Accel", "number");
        this.addOutput("Next", LiteGraph.EVENT);
        this.properties = { accel: 1 };
        this.addWidget("number", "Accel (rev/s¬≤)", this.properties.accel, (v) => { 
          this.properties.accel = Math.max(0.1, v); 
        }, { min: 0.1, step: 0.1 });
        this.size = [180, 60];
        this.color = "#78909c";
        this.bgcolor = "#37474f";
      }
      PipetteSetAccelNode.title = "Set Acceleration";
      PipetteSetAccelNode.desc = "Set acceleration (rev/s¬≤)";
      PipetteSetAccelNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        const accel = this.getInputData(1) ?? this.properties.accel;
        try {
          await controller.executeToolCommand({ cmd: 'a', inputType: 'float', isQueue: false }, accel);
          this.triggerSlot(0);
        } catch (e) {
          console.error("Pipette set accel error:", e);
        }
      };
      LiteGraph.registerNodeType("pipette/set_accel", PipetteSetAccelNode);
      
      // ===== Pipette Set Max Speed Node =====
      function PipetteSetSpeedNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addInput("Speed", "number");
        this.addOutput("Next", LiteGraph.EVENT);
        this.properties = { speed: 3 };
        this.addWidget("number", "Speed (rev/s)", this.properties.speed, (v) => { 
          this.properties.speed = Math.max(0.1, v); 
        }, { min: 0.1, step: 0.1 });
        this.size = [180, 60];
        this.color = "#78909c";
        this.bgcolor = "#37474f";
      }
      PipetteSetSpeedNode.title = "Set Max Speed";
      PipetteSetSpeedNode.desc = "Set max speed (rev/s)";
      PipetteSetSpeedNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        const speed = this.getInputData(1) ?? this.properties.speed;
        try {
          await controller.executeToolCommand({ cmd: 'x', inputType: 'float', isQueue: false }, speed);
          this.triggerSlot(0);
        } catch (e) {
          console.error("Pipette set speed error:", e);
        }
      };
      LiteGraph.registerNodeType("pipette/set_speed", PipetteSetSpeedNode);
      
      // ===== Pipette Stop Node =====
      function PipetteStopNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Next", LiteGraph.EVENT);
        this.size = [180, 30];
        this.color = "#ffa726";
        this.bgcolor = "#e65100";
      }
      PipetteStopNode.title = "Stop";
      PipetteStopNode.desc = "Stop pipette motor";
      PipetteStopNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        try {
          await controller.sendImmediate('ms');
          this.triggerSlot(0);
        } catch (e) {
          console.error("Pipette stop error:", e);
        }
      };
      LiteGraph.registerNodeType("pipette/stop", PipetteStopNode);
      
      // ===== Pipette Emergency Stop Node =====
      function PipetteEmergencyStopNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Next", LiteGraph.EVENT);
        this.size = [180, 30];
        this.color = "#ef5350";
        this.bgcolor = "#b71c1c";
      }
      PipetteEmergencyStopNode.title = "Emergency Stop";
      PipetteEmergencyStopNode.desc = "Emergency stop pipette";
      PipetteEmergencyStopNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        try {
          await controller.sendImmediate('me');
          this.triggerSlot(0);
        } catch (e) {
          console.error("Pipette emergency stop error:", e);
        }
      };
      LiteGraph.registerNodeType("pipette/emergency", PipetteEmergencyStopNode);
      
      // ===== Pipette Get Position Node =====
      function PipetteGetPositionNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addOutput("Next", LiteGraph.EVENT);
        this.addOutput("Position", "number");
        this.addOutput("Status", "string");
        this.size = [180, 80];
        this.color = "#42a5f5";
        this.bgcolor = "#0d47a1";
        this._position = 0;
        this._status = "UNKNOWN";
      }
      PipetteGetPositionNode.title = "Get Position";
      PipetteGetPositionNode.desc = "Get current position";
      PipetteGetPositionNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        try {
          await controller.sendImmediate('mp');
          // Position will be updated via AUX response handler
          this.triggerSlot(0);
        } catch (e) {
          console.error("Pipette get position error:", e);
        }
      };
      PipetteGetPositionNode.prototype.onExecute = function() {
        this.setOutputData(1, this._position);
        this.setOutputData(2, this._status);
      };
      LiteGraph.registerNodeType("pipette/get_position", PipetteGetPositionNode);
      
      // ===== Pipette Set Limit Compensation Node =====
      function PipetteLimitCompNode() {
        this.addInput("Trigger", LiteGraph.ACTION);
        this.addInput("Ratio", "number");
        this.addOutput("Next", LiteGraph.EVENT);
        this.properties = { ratio: 1.0 };
        this.addWidget("number", "Ratio", this.properties.ratio, (v) => { 
          this.properties.ratio = Math.max(0, v); 
        }, { min: 0, step: 0.1 });
        this.size = [180, 60];
        this.color = "#78909c";
        this.bgcolor = "#37474f";
      }
      PipetteLimitCompNode.title = "Set Limit Compensation";
      PipetteLimitCompNode.desc = "Set limit compensation ratio";
      PipetteLimitCompNode.prototype.onAction = async function() {
        if (!controller || !controller.isConnected) return;
        const ratio = this.getInputData(1) ?? this.properties.ratio;
        try {
          await controller.executeToolCommand({ cmd: 'i', inputType: 'float', isQueue: false }, ratio);
          this.triggerSlot(0);
        } catch (e) {
          console.error("Pipette limit comp error:", e);
        }
      };
      LiteGraph.registerNodeType("pipette/limit_comp", PipetteLimitCompNode);
      
      // ========================================
      // Bench Components Nodes
      // ========================================
      
      // ===== 96 Tip Box (200¬µL) Node =====
      function TipBox96Node() {
        this.addInput("Index", "number");
        this.addOutput("X (mm)", "number");
        this.addOutput("Y (mm)", "number");
        this.addOutput("Z (mm)", "number");
        this.addOutput("Valid", "boolean");
        
        // Use global componentSettings as defaults
        const tipSettings = componentSettings?.tipBox96 || { offsetX: 14.38, offsetY: 11.24, spacingX: 9, spacingY: 9, zPosition: 50 };
        
        this.properties = {
          gridX: 0,       // Grid position X (mm) - set by bench grid
          gridY: 0,       // Grid position Y (mm) - set by bench grid
          offsetX: tipSettings.offsetX, // A1 offset from grid origin (mm)
          offsetY: tipSettings.offsetY, // A1 offset from grid origin (mm)
          spacingX: tipSettings.spacingX,    // Well spacing X (mm)
          spacingY: tipSettings.spacingY,    // Well spacing Y (mm)
          zPosition: tipSettings.zPosition,  // Z position (mm)
          enabledWells: new Array(96).fill(true) // All wells enabled by default
        };
        
        this.wellLabels = [];
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 12; col++) {
            this.wellLabels.push(String.fromCharCode(65 + row) + (col + 1));
          }
        }
        
        // Widget to show/edit enabled wells (simplified)
        this.addWidget("button", "Configure Wells", null, () => {
          this.showWellConfig();
        });
        
        this.color = "#89b4fa";
        this.bgcolor = "#1e3a5f";
      }
      TipBox96Node.title = "96 Tip Box";
      TipBox96Node.desc = "96-well tip box (200¬µL) - returns position based on index";
      
      TipBox96Node.prototype.showWellConfig = function() {
        const modal = document.getElementById('well-config-modal');
        const grid = document.getElementById('well-grid');
        const node = this;
        
        // Store reference for save
        window.currentWellNode = node;
        window.tempEnabledWells = [...node.properties.enabledWells];
        
        // Render grid
        grid.innerHTML = '';
        const rows = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
        
        rows.forEach((rowLabel, rowIdx) => {
          // Row label
          const rowLabelEl = document.createElement('div');
          rowLabelEl.className = 'text-center text-xs font-bold opacity-70 flex items-center justify-center';
          rowLabelEl.textContent = rowLabel;
          rowLabelEl.dataset.row = rowIdx;
          rowLabelEl.style.cursor = 'pointer';
          rowLabelEl.onclick = () => toggleRow(rowIdx);
          grid.appendChild(rowLabelEl);
          
          // Wells in row
          for (let col = 0; col < 12; col++) {
            const wellIdx = rowIdx * 12 + col;
            const wellEl = document.createElement('button');
            wellEl.type = 'button';
            wellEl.className = 'btn btn-xs aspect-square p-0 min-h-0 h-8 ' + 
              (window.tempEnabledWells[wellIdx] ? 'btn-primary' : 'btn-ghost opacity-40');
            wellEl.dataset.well = wellIdx;
            wellEl.dataset.row = rowIdx;
            wellEl.dataset.col = col;
            wellEl.textContent = rowLabel + (col + 1);
            wellEl.style.fontSize = '9px';
            wellEl.onclick = () => toggleWell(wellIdx);
            grid.appendChild(wellEl);
          }
        });
        
        updateWellCount();
        modal.showModal();
      };
      
      function toggleWell(idx) {
        window.tempEnabledWells[idx] = !window.tempEnabledWells[idx];
        const btn = document.querySelector(`[data-well="${idx}"]`);
        if (window.tempEnabledWells[idx]) {
          btn.className = 'btn btn-xs aspect-square p-0 min-h-0 h-8 btn-primary';
        } else {
          btn.className = 'btn btn-xs aspect-square p-0 min-h-0 h-8 btn-ghost opacity-40';
        }
        updateWellCount();
      }
      
      function toggleRow(rowIdx) {
        const startIdx = rowIdx * 12;
        const allEnabled = window.tempEnabledWells.slice(startIdx, startIdx + 12).every(w => w);
        for (let i = 0; i < 12; i++) {
          window.tempEnabledWells[startIdx + i] = !allEnabled;
          const btn = document.querySelector(`[data-well="${startIdx + i}"]`);
          if (!allEnabled) {
            btn.className = 'btn btn-xs aspect-square p-0 min-h-0 h-8 btn-primary';
          } else {
            btn.className = 'btn btn-xs aspect-square p-0 min-h-0 h-8 btn-ghost opacity-40';
          }
        }
        updateWellCount();
      }
      
      function toggleCol(colIdx) {
        const allEnabled = [0,1,2,3,4,5,6,7].every(r => window.tempEnabledWells[r * 12 + colIdx]);
        for (let r = 0; r < 8; r++) {
          const idx = r * 12 + colIdx;
          window.tempEnabledWells[idx] = !allEnabled;
          const btn = document.querySelector(`[data-well="${idx}"]`);
          if (!allEnabled) {
            btn.className = 'btn btn-xs aspect-square p-0 min-h-0 h-8 btn-primary';
          } else {
            btn.className = 'btn btn-xs aspect-square p-0 min-h-0 h-8 btn-ghost opacity-40';
          }
        }
        updateWellCount();
      }
      
      function updateWellCount() {
        const enabled = window.tempEnabledWells.filter(w => w).length;
        document.getElementById('well-count').textContent = `${enabled}/96 enabled`;
      }
      
      TipBox96Node.prototype.getEnabledIndex = function(index) {
        // Convert user index (1-based, skipping disabled) to actual well index
        let count = 0;
        for (let i = 0; i < 96; i++) {
          if (this.properties.enabledWells[i]) {
            count++;
            if (count === index) {
              return i;
            }
          }
        }
        return -1; // Invalid index
      };
      
      TipBox96Node.prototype.getWellPosition = function(wellIndex) {
        // wellIndex is 0-based (0-95)
        const row = Math.floor(wellIndex / 12); // 0-7 (A-H)
        const col = wellIndex % 12;              // 0-11 (1-12)
        
        const x = this.properties.gridX + this.properties.offsetX + (col * this.properties.spacingX);
        const y = this.properties.gridY + this.properties.offsetY + (row * this.properties.spacingY);
        
        return { x, y, label: this.wellLabels[wellIndex] };
      };
      
      TipBox96Node.prototype.onExecute = function() {
        const inputIndex = this.getInputData(0) ?? 1;
        const actualIndex = this.getEnabledIndex(Math.floor(inputIndex));
        
        if (actualIndex >= 0 && actualIndex < 96) {
          const pos = this.getWellPosition(actualIndex);
          this.setOutputData(0, pos.x);
          this.setOutputData(1, pos.y);
          this.setOutputData(2, this.properties.zPosition);
          this.setOutputData(3, true);
        } else {
          this.setOutputData(0, 0);
          this.setOutputData(1, 0);
          this.setOutputData(2, 0);
          this.setOutputData(3, false);
        }
      };
      
      LiteGraph.registerNodeType("bench/tip-box-96", TipBox96Node);
      
      // ===== 96 Well Plate Node =====
      function WellPlate96Node() {
        this.addInput("Index", "number");
        this.addOutput("X (mm)", "number");
        this.addOutput("Y (mm)", "number");
        this.addOutput("Z (mm)", "number");
        this.addOutput("Valid", "boolean");
        
        // Use global componentSettings as defaults
        const plateSettings = componentSettings?.wellPlate96 || { offsetX: 14.38, offsetY: 11.24, spacingX: 9, spacingY: 9, zPosition: 30 };
        
        this.properties = {
          gridX: 0,
          gridY: 0,
          offsetX: plateSettings.offsetX,
          offsetY: plateSettings.offsetY,
          spacingX: plateSettings.spacingX,
          spacingY: plateSettings.spacingY,
          zPosition: plateSettings.zPosition,
          enabledWells: new Array(96).fill(true)
        };
        
        this.wellLabels = [];
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 12; col++) {
            this.wellLabels.push(String.fromCharCode(65 + row) + (col + 1));
          }
        }
        
        this.addWidget("button", "Configure Wells", null, () => {
          this.showWellConfig();
        });
        
        this.color = "#f9e2af";
        this.bgcolor = "#5c4a1f";
      }
      WellPlate96Node.title = "96 Well Plate";
      WellPlate96Node.desc = "Standard 96-well microplate";
      
      // Share methods with TipBox96Node
      WellPlate96Node.prototype.showWellConfig = TipBox96Node.prototype.showWellConfig;
      WellPlate96Node.prototype.getEnabledIndex = TipBox96Node.prototype.getEnabledIndex;
      WellPlate96Node.prototype.getWellPosition = TipBox96Node.prototype.getWellPosition;
      WellPlate96Node.prototype.onExecute = TipBox96Node.prototype.onExecute;
      
      LiteGraph.registerNodeType("bench/wellplate-96", WellPlate96Node);
      
      // ===== Reservoir Node =====
      function ReservoirNode() {
        // No input - just outputs the position
        this.addOutput("X (mm)", "number");
        this.addOutput("Y (mm)", "number");
        this.addOutput("Z (mm)", "number");
        
        // Use global componentSettings as defaults
        const resSettings = componentSettings?.reservoir || { offsetX: 50, offsetY: 40, zPosition: 20 };
        
        this.properties = {
          gridX: 0,       // Grid position X (mm) - set by bench grid
          gridY: 0,       // Grid position Y (mm) - set by bench grid
          offsetX: resSettings.offsetX,  // Offset from grid origin (mm)
          offsetY: resSettings.offsetY,  // Offset from grid origin (mm)
          zPosition: resSettings.zPosition // Z position (mm)
        };
        
        this.color = "#94e2d5";
        this.bgcolor = "#1e4d4a";
      }
      ReservoirNode.title = "Reservoir";
      ReservoirNode.desc = "Single channel reservoir - outputs absolute position";
      
      ReservoirNode.prototype.onExecute = function() {
        const x = this.properties.gridX + this.properties.offsetX;
        const y = this.properties.gridY + this.properties.offsetY;
        const z = this.properties.zPosition;
        
        this.setOutputData(0, x);
        this.setOutputData(1, y);
        this.setOutputData(2, z);
      };
      
      LiteGraph.registerNodeType("bench/reservoir", ReservoirNode);
    }

    function addDefaultNodes() {
      // Add a button node
      const buttonNode = LiteGraph.createNode("util/button");
      buttonNode.pos = [100, 200];
      graph.add(buttonNode);
      
      // Add a move node
      const moveNode = LiteGraph.createNode("motor/move");
      moveNode.pos = [300, 200];
      graph.add(moveNode);
      
      // Add position node
      const posNode = LiteGraph.createNode("motor/position");
      posNode.pos = [100, 350];
      graph.add(posNode);
      
      // Connect button to move
      buttonNode.connect(0, moveNode, 0);
    }
    
    // ========================================
    // UI Event Handlers
    // ========================================
    function initUIEvents() {
      // Tab switching
      document.querySelectorAll('.tabs .tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const tabId = tab.getAttribute('data-tab');
          
          // Remove active from all tabs
          document.querySelectorAll('.tabs .tab').forEach(t => t.classList.remove('tab-active'));
          
          // Hide all tab panels
          document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.add('hidden'));
          
          // Activate clicked tab
          tab.classList.add('tab-active');
          
          // Show corresponding panel
          const panel = document.getElementById('tab-' + tabId);
          if (panel) {
            panel.classList.remove('hidden');
          }
          
          // Resize LiteGraph canvas if switching to control tab
          if (tabId === 'control' && graph && graphCanvas) {
            setTimeout(() => graphCanvas.resize(), 100);
          }
        });
      });
      
      // 96 Well Config Modal handlers
      document.getElementById('well-select-all').addEventListener('click', () => {
        window.tempEnabledWells = new Array(96).fill(true);
        document.querySelectorAll('[data-well]').forEach(btn => {
          btn.className = 'btn btn-xs aspect-square p-0 min-h-0 h-8 btn-primary';
        });
        updateWellCount();
      });
      
      document.getElementById('well-deselect-all').addEventListener('click', () => {
        window.tempEnabledWells = new Array(96).fill(false);
        document.querySelectorAll('[data-well]').forEach(btn => {
          btn.className = 'btn btn-xs aspect-square p-0 min-h-0 h-8 btn-ghost opacity-40';
        });
        updateWellCount();
      });
      
      document.getElementById('well-select-row').addEventListener('click', () => {
        const row = prompt('Enter row (A-H):');
        if (row && /^[A-Ha-h]$/.test(row)) {
          const rowIdx = row.toUpperCase().charCodeAt(0) - 65;
          toggleRow(rowIdx);
        }
      });
      
      document.getElementById('well-select-col').addEventListener('click', () => {
        const col = prompt('Enter column (1-12):');
        const colNum = parseInt(col);
        if (colNum >= 1 && colNum <= 12) {
          toggleCol(colNum - 1);
        }
      });
      
      document.getElementById('well-config-save').addEventListener('click', () => {
        if (window.currentWellNode) {
          window.currentWellNode.properties.enabledWells = [...window.tempEnabledWells];
        }
        document.getElementById('well-config-modal').close();
      });
      
      document.getElementById('well-config-cancel').addEventListener('click', () => {
        document.getElementById('well-config-modal').close();
      });
      
      // Connect button
      document.getElementById('btn-connect').addEventListener('click', async () => {
        if (!controller.isConnected) {
          const success = await controller.connect();
          if (success) {
            updateConnectionStatus(true);
            controller.startToolRefresh();
          }
        } else {
          controller.stopToolRefresh();
          await controller.disconnect();
          updateConnectionStatus(false);
        }
      });
      
      // Emergency stop
      document.getElementById('btn-emergency').addEventListener('click', async () => {
        if (controller && controller.isConnected) {
          await controller.emergencyStop();
        }
      });
      
      // Stop button in jog controls
      document.getElementById('btn-stop').addEventListener('click', async () => {
        if (controller && controller.isConnected) {
          await controller.stop();
        }
      });
      
      // Jog buttons (mm based)
      document.querySelectorAll('[data-jog-mm]').forEach(btn => {
        btn.addEventListener('click', async () => {
          if (!controller || !controller.isConnected) return;
          
          const jogCmd = btn.getAttribute('data-jog-mm');
          const stepSizeMM = parseFloat(document.getElementById('jog-step-mm').value);
          
          // Parse command: "X:+" or "Y:-" etc
          const parts = jogCmd.split(':');
          const axis = parts[0]; // X, Y, Z
          const direction = parts[1]; // + or -
          
          // Map axis to motor
          const motorMap = { 'X': 1, 'Y': 2, 'Z': 3 };
          const motorKey = { 'X': 'm1', 'Y': 'm2', 'Z': 'm3' };
          const motor = motorMap[axis];
          const steps = mmToSteps(stepSizeMM, motorKey[axis]);
          const dirChar = direction === '+' ? 'F' : 'B';
          
          const finalCmd = `M${motor}:${dirChar}${steps}`;
          await controller.send(finalCmd);
        });
      });
      
      // Go To Position (mm based)
      document.getElementById('btn-goto').addEventListener('click', async () => {
        if (!controller || !controller.isConnected) return;
        
        const xMM = parseFloat(document.getElementById('goto-x').value) || 0;
        const yMM = parseFloat(document.getElementById('goto-y').value) || 0;
        const zMM = parseFloat(document.getElementById('goto-z').value) || 0;
        
        // Convert mm to steps
        const xSteps = mmToSteps(xMM, 'm1');
        const ySteps = mmToSteps(yMM, 'm2');
        const zSteps = mmToSteps(zMM, 'm3');
        
        await controller.moveAll(xSteps, ySteps, zSteps);
      });
      
      // Settings sliders
      document.getElementById('speed-slider').addEventListener('input', (e) => {
        document.getElementById('speed-value').textContent = e.target.value;
      });
      
      document.getElementById('accel-slider').addEventListener('input', (e) => {
        document.getElementById('accel-value').textContent = e.target.value;
      });
      
      document.getElementById('btn-apply-settings').addEventListener('click', async () => {
        if (!controller || !controller.isConnected) return;
        
        const speed = parseFloat(document.getElementById('speed-slider').value);
        const accel = parseFloat(document.getElementById('accel-slider').value);
        
        await controller.setSpeed(speed);
        await controller.setAcceleration(accel);
      });
      
      // Save Steps per 100mm
      document.getElementById('btn-save-steps').addEventListener('click', () => {
        saveStepSettings();
      });
      
      // Set Home
      document.getElementById('btn-set-home').addEventListener('click', async () => {
        if (!controller || !controller.isConnected) return;
        await controller.setHome();
      });
      
      // Calibration
      document.getElementById('btn-calibrate').addEventListener('click', async () => {
        if (!controller || !controller.isConnected) return;
        
        const modal = document.getElementById('calibration-modal');
        modal.showModal();
        
        try {
          const result = await controller.calibration();
          document.getElementById('calibration-status').textContent = 
            `Done! Size: X=${result.motor1}, Y=${result.motor2}, Z=${result.motor3}`;
          
          setTimeout(() => modal.close(), 2000);
        } catch (e) {
          document.getElementById('calibration-status').textContent = `Error: ${e.message}`;
        }
      });
      
      // Clear log
      document.getElementById('btn-clear-log').addEventListener('click', () => {
        document.getElementById('log-container').innerHTML = '';
      });
    }
    
    // ========================================
    // Helper Functions
    // ========================================
    function updateConnectionStatus(connected) {
      const indicator = document.getElementById('status-indicator');
      const text = document.getElementById('status-text');
      const connectBtn = document.getElementById('btn-connect');
      const estopBtn = document.getElementById('btn-emergency');
      
      if (connected) {
        indicator.classList.remove('disconnected');
        indicator.classList.add('connected');
        text.textContent = 'Connected';
        connectBtn.textContent = 'Disconnect';
        connectBtn.classList.remove('btn-primary');
        connectBtn.classList.add('btn-ghost');
        estopBtn.disabled = false;
      } else {
        indicator.classList.remove('connected');
        indicator.classList.add('disconnected');
        text.textContent = 'Disconnected';
        connectBtn.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
          </svg>
          Connect
        `;
        connectBtn.classList.add('btn-primary');
        connectBtn.classList.remove('btn-ghost');
        estopBtn.disabled = true;
      }
    }
    
    function handleMotorData(data) {
      // Update motor status displays
      if (data.motor === 'Motor1' || data.motorName === 'Motor1') {
        document.getElementById('m1-position').textContent = data.position ?? '-';
        document.getElementById('m1-status').textContent = data.status ?? 'UNKNOWN';
        // Update Quick Controls position display (mm)
        const posXmm = document.getElementById('pos-x-mm');
        if (posXmm) posXmm.textContent = stepsToMM(data.position ?? 0, 'm1').toFixed(2);
      }
      if (data.motor === 'Motor2' || data.motorName === 'Motor2') {
        document.getElementById('m2-position').textContent = data.position ?? '-';
        document.getElementById('m2-status').textContent = data.status ?? 'UNKNOWN';
        const posYmm = document.getElementById('pos-y-mm');
        if (posYmm) posYmm.textContent = stepsToMM(data.position ?? 0, 'm2').toFixed(2);
      }
      if (data.motor === 'Motor3' || data.motorName === 'Motor3') {
        document.getElementById('m3-position').textContent = data.position ?? '-';
        document.getElementById('m3-status').textContent = data.status ?? 'UNKNOWN';
        const posZmm = document.getElementById('pos-z-mm');
        if (posZmm) posZmm.textContent = stepsToMM(data.position ?? 0, 'm3').toFixed(2);
      }
    }
    
    function addLog(message, type = 'info') {
      const container = document.getElementById('log-container');
      const entry = document.createElement('div');
      entry.className = `log-entry log-${type}`;
      
      const time = new Date().toLocaleTimeString();
      entry.textContent = `[${time}] ${message}`;
      
      container.appendChild(entry);
      container.scrollTop = container.scrollHeight;
      
      // Limit entries
      while (container.children.length > 100) {
        container.removeChild(container.firstChild);
      }
    }
    
    function updateQueueDisplay(action, item) {
      const queueList = document.getElementById('queue-list');
      const queueCount = document.getElementById('queue-count');
      
      if (action === 'clear') {
        queueList.innerHTML = '<p class="opacity-50">No commands in queue</p>';
        queueCount.textContent = '0';
        return;
      }
      
      const count = controller.commandQueue.length;
      queueCount.textContent = count;
      
      if (count === 0) {
        queueList.innerHTML = '<p class="opacity-50">No commands in queue</p>';
      } else {
        queueList.innerHTML = controller.commandQueue.map((cmd, i) => `
          <div class="p-1 ${i === 0 ? 'bg-primary/20' : ''} rounded">
            ${cmd.command}
          </div>
        `).join('');
      }
    }
    
    function updateToolPanel(name, commands) {
      document.getElementById('tool-name').textContent = name || 'No tool connected';
      
      const commandsContainer = document.getElementById('tool-commands');
      
      if (!commands || commands.length === 0) {
        commandsContainer.innerHTML = '<p class="text-xs opacity-50">No commands available</p>';
        return;
      }
      
      commandsContainer.innerHTML = commands.map(cmd => {
        if (cmd.inputType && cmd.inputType !== 'none') {
          return `
            <div class="flex gap-1">
              <input type="${cmd.inputType === 'number' ? 'number' : 'text'}" 
                     class="input input-bordered input-xs flex-1" 
                     placeholder="${cmd.name}"
                     data-cmd='${JSON.stringify(cmd)}' />
              <button class="btn btn-xs btn-primary tool-cmd-btn" data-cmd='${JSON.stringify(cmd)}'>
                Send
              </button>
            </div>
          `;
        } else {
          return `
            <button class="btn btn-xs btn-ghost w-full tool-cmd-btn" data-cmd='${JSON.stringify(cmd)}'>
              ${cmd.name}
            </button>
          `;
        }
      }).join('');
      
      // Add event listeners
      commandsContainer.querySelectorAll('.tool-cmd-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const cmd = JSON.parse(e.target.getAttribute('data-cmd'));
          let value = null;
          
          // Check if there's an input field for this command
          const input = e.target.previousElementSibling;
          if (input && input.tagName === 'INPUT') {
            value = input.value;
          }
          
          if (controller && controller.isConnected) {
            await controller.executeToolCommand(cmd, value);
          }
        });
      });
    }
    
    // ========================================
    // Drag & Drop Command Blocks
    // ========================================
    function initDragDrop() {
      const canvas = document.getElementById('graph-canvas');
      let draggedType = null;
      
      // Node type mapping from command blocks
      const nodeTypeMap = {
        'motor/move': 'motor/move',
        'motor/move_xy': 'motor/move_xy',
        'motor/move_single': 'motor/move_single',
        'motor/move_relative': 'motor/move_relative',
        'motor/stop': 'motor/stop',
        'motor/emergency': 'motor/emergency',
        'motor/set_home': 'motor/set_home',
        'motor/wait_idle': 'motor/wait_idle',
        'motor/enable': 'motor/enable',
        'motor/disable': 'motor/disable',
        'motor/set_speed': 'motor/set_speed',
        'motor/set_accel': 'motor/set_accel',
        'motor/calibrate': 'motor/calibrate',
        'motor/position': 'motor/position',
        'motor/status': 'motor/status',
        'motor/limit': 'motor/limit',
        'motor/aux_command': 'motor/aux_command',
        'motor/aux_query': 'motor/aux_query',
        'util/button': 'util/button',
        'util/delay': 'util/delay',
        'util/loop': 'util/loop',
        'util/number': 'util/number',
        'util/sequence': 'util/sequence',
        'util/comment': 'util/comment',
        'bench/tip-box-96': 'bench/tip-box-96'
      };
      
      // Setup drag events on command blocks (use data-node attribute)
      document.querySelectorAll('.cmd-block[data-node]').forEach(block => {
        block.addEventListener('dragstart', (e) => {
          draggedType = block.getAttribute('data-node');
          e.dataTransfer.setData('text/plain', draggedType);
          e.dataTransfer.effectAllowed = 'copy';
          block.classList.add('opacity-50');
          console.log('Drag started:', draggedType);
        });
        
        block.addEventListener('dragend', (e) => {
          block.classList.remove('opacity-50');
          canvas.classList.remove('drag-over');
          draggedType = null;
        });
      });
      
      // Setup drop zone on canvas
      canvas.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
        canvas.classList.add('drag-over');
      });
      
      canvas.addEventListener('dragleave', (e) => {
        canvas.classList.remove('drag-over');
      });
      
      canvas.addEventListener('drop', (e) => {
        e.preventDefault();
        e.stopPropagation();
        canvas.classList.remove('drag-over');
        
        const nodeType = e.dataTransfer.getData('text/plain');
        console.log('Drop received:', nodeType);
        
        if (!nodeType || !nodeTypeMap[nodeType]) {
          console.log('Invalid node type:', nodeType);
          return;
        }
        
        // Calculate position relative to graph using LiteGraph canvas methods
        const rect = canvas.getBoundingClientRect();
        const canvasX = e.clientX - rect.left;
        const canvasY = e.clientY - rect.top;
        
        // Convert to graph coordinates
        const graphPos = graphCanvas.convertEventToCanvasOffset(e);
        const x = graphPos[0];
        const y = graphPos[1];
        
        console.log('Creating node at:', x, y);
        
        // Create the node
        const node = LiteGraph.createNode(nodeTypeMap[nodeType]);
        if (node) {
          node.pos = [x, y];
          graph.add(node);
          graphCanvas.setDirty(true, true);
          addLog(`Added node: ${node.title}`, 'info');
          console.log('Node added successfully:', node.title);
        } else {
          console.log('Failed to create node:', nodeType);
        }
      });
      
      // Collapse/expand panels
      document.querySelectorAll('.cmd-panel-header').forEach(header => {
        header.addEventListener('click', () => {
          const content = header.nextElementSibling;
          const icon = header.querySelector('.collapse-icon');
          
          if (content.style.display === 'none') {
            content.style.display = 'flex';
            icon.textContent = '‚ñº';
          } else {
            content.style.display = 'none';
            icon.textContent = '‚ñ∂';
          }
        });
      });
    }
    
    // ========================================
    // Setup Wizard System
    // ========================================
    let wizardState = {
      currentPage: 1,
      isConnected: false,
      isCalibrated: false,
      calibrationData: { x: 0, y: 0, z: 0 }
    };
    
    function checkAndShowSetupWizard() {
      // Check if setup was completed before
      const setupComplete = localStorage.getItem('brionette_setup_complete');
      if (!setupComplete) {
        showSetupWizard();
      }
    }
    
    function showSetupWizard() {
      const modal = document.getElementById('setup-wizard-modal');
      modal.showModal();
      updateWizardUI();
    }
    
    function initSetupWizard() {
      // Connect button
      document.getElementById('wizard-btn-connect')?.addEventListener('click', async () => {
        const btn = document.getElementById('wizard-btn-connect');
        const status = document.getElementById('wizard-connect-status');
        
        btn.classList.add('loading');
        
        try {
          const success = await controller.connect();
          if (success) {
            wizardState.isConnected = true;
            status.className = 'badge badge-success';
            status.textContent = 'Connected';
            btn.textContent = '‚úì Connected';
            btn.disabled = true;
            document.getElementById('wizard-btn-calibrate').disabled = false;
          } else {
            status.className = 'badge badge-error';
            status.textContent = 'Failed';
          }
        } catch (e) {
          status.className = 'badge badge-error';
          status.textContent = 'Error: ' + e.message;
        }
        
        btn.classList.remove('loading');
        updateWizardUI();
      });
      
      // Calibrate button
      document.getElementById('wizard-btn-calibrate')?.addEventListener('click', async () => {
        const btn = document.getElementById('wizard-btn-calibrate');
        const status = document.getElementById('wizard-calibrate-status');
        
        btn.classList.add('loading');
        status.className = 'badge badge-warning';
        status.textContent = 'Calibrating...';
        
        try {
          // Run calibration
          await controller.send('CAL');
          
          // Wait for calibration to complete (simplified - in real app would poll status)
          await new Promise(resolve => setTimeout(resolve, 3000));
          
          // Get max positions
          const response = await controller.send('?MAX');
          
          // Parse calibration results (mock for now)
          // In real implementation, parse actual response
          wizardState.calibrationData = {
            x: parseInt(document.getElementById('wizard-x-steps')?.textContent) || 48000,
            y: parseInt(document.getElementById('wizard-y-steps')?.textContent) || 48000,
            z: parseInt(document.getElementById('wizard-z-steps')?.textContent) || 16000
          };
          
          // Update display
          document.getElementById('wizard-x-steps').textContent = wizardState.calibrationData.x;
          document.getElementById('wizard-y-steps').textContent = wizardState.calibrationData.y;
          document.getElementById('wizard-z-steps').textContent = wizardState.calibrationData.z;
          
          wizardState.isCalibrated = true;
          status.className = 'badge badge-success';
          status.textContent = 'Calibrated';
          btn.textContent = '‚úì Calibrated';
          btn.disabled = true;
          
        } catch (e) {
          status.className = 'badge badge-error';
          status.textContent = 'Error';
          console.error('Calibration error:', e);
        }
        
        btn.classList.remove('loading');
        updateWizardUI();
      });
      
      // Navigation buttons
      document.getElementById('wizard-btn-prev')?.addEventListener('click', () => {
        if (wizardState.currentPage > 1) {
          wizardState.currentPage--;
          updateWizardUI();
        }
      });
      
      document.getElementById('wizard-btn-next')?.addEventListener('click', () => {
        if (wizardState.currentPage < 4) {
          // Save data from current page before moving
          if (wizardState.currentPage === 2) {
            saveWizardStep2Data();
          }
          if (wizardState.currentPage === 3) {
            prepareStep4Summary();
          }
          wizardState.currentPage++;
          updateWizardUI();
        }
      });
      
      document.getElementById('wizard-btn-finish')?.addEventListener('click', () => {
        finishSetupWizard();
      });
      
      // Debug shortcut: Alt+S to skip wizard
      document.addEventListener('keydown', (e) => {
        if (e.altKey && e.key.toLowerCase() === 's') {
          const modal = document.getElementById('setup-wizard-modal');
          if (modal.open) {
            console.log('[DEBUG] Wizard skipped with Alt+S');
            modal.close();
            addLog('Setup wizard skipped (debug mode)', 'warning');
          }
        }
      });
    }
    
    function updateWizardUI() {
      const page = wizardState.currentPage;
      
      // Update step indicators
      for (let i = 1; i <= 4; i++) {
        const step = document.getElementById(`wizard-step-${i}`);
        step.classList.toggle('step-primary', i <= page);
      }
      
      // Show/hide pages
      for (let i = 1; i <= 4; i++) {
        const pageEl = document.getElementById(`wizard-page-${i}`);
        pageEl.classList.toggle('hidden', i !== page);
      }
      
      // Update navigation buttons
      const prevBtn = document.getElementById('wizard-btn-prev');
      const nextBtn = document.getElementById('wizard-btn-next');
      const finishBtn = document.getElementById('wizard-btn-finish');
      
      prevBtn.disabled = page === 1;
      
      // Next button availability depends on page
      let canNext = false;
      if (page === 1) {
        canNext = wizardState.isConnected && wizardState.isCalibrated;
      } else if (page === 2) {
        canNext = true; // Always can proceed from step 2
      } else if (page === 3) {
        canNext = true;
      }
      
      nextBtn.disabled = !canNext;
      nextBtn.classList.toggle('hidden', page === 4);
      finishBtn.classList.toggle('hidden', page !== 4);
      
      // Prepare data for specific pages
      if (page === 3) {
        prepareStep3Summary();
      }
    }
    
    function saveWizardStep2Data() {
      // Save steps per 100mm
      stepSettings.m1 = parseInt(document.getElementById('wizard-steps-x').value) || 1600;
      stepSettings.m2 = parseInt(document.getElementById('wizard-steps-y').value) || 1600;
      stepSettings.m3 = parseInt(document.getElementById('wizard-steps-z').value) || 1600;
      saveStepSettings();
      
      // Save bench grid settings
      benchSettings.cellSize = parseInt(document.getElementById('wizard-cell-size').value) || 140;
      document.getElementById('bench-cols').value = document.getElementById('wizard-grid-cols').value;
      document.getElementById('bench-rows').value = document.getElementById('wizard-grid-rows').value;
      document.getElementById('bench-cell-size').value = benchSettings.cellSize;
    }
    
    function prepareStep3Summary() {
      const stepsX = parseInt(document.getElementById('wizard-steps-x').value) || 1600;
      const stepsY = parseInt(document.getElementById('wizard-steps-y').value) || 1600;
      const stepsZ = parseInt(document.getElementById('wizard-steps-z').value) || 1600;
      
      const maxStepsX = wizardState.calibrationData.x;
      const maxStepsY = wizardState.calibrationData.y;
      const maxStepsZ = wizardState.calibrationData.z;
      
      // Calculate max mm
      const maxMmX = (maxStepsX / stepsX * 100).toFixed(1);
      const maxMmY = (maxStepsY / stepsY * 100).toFixed(1);
      const maxMmZ = (maxStepsZ / stepsZ * 100).toFixed(1);
      
      document.getElementById('wizard-sum-x-steps').textContent = maxStepsX;
      document.getElementById('wizard-sum-x-per100').textContent = stepsX;
      document.getElementById('wizard-sum-x-mm').textContent = maxMmX + ' mm';
      
      document.getElementById('wizard-sum-y-steps').textContent = maxStepsY;
      document.getElementById('wizard-sum-y-per100').textContent = stepsY;
      document.getElementById('wizard-sum-y-mm').textContent = maxMmY + ' mm';
      
      document.getElementById('wizard-sum-z-steps').textContent = maxStepsZ;
      document.getElementById('wizard-sum-z-per100').textContent = stepsZ;
      document.getElementById('wizard-sum-z-mm').textContent = maxMmZ + ' mm';
      
      // Store for motor max
      benchSettings.motorMax = {
        m1: parseFloat(maxMmX),
        m2: parseFloat(maxMmY),
        m3: parseFloat(maxMmZ)
      };
    }
    
    function prepareStep4Summary() {
      const cols = document.getElementById('wizard-grid-cols').value;
      const rows = document.getElementById('wizard-grid-rows').value;
      
      document.getElementById('wizard-final-area').textContent = 
        `${benchSettings.motorMax.m1} √ó ${benchSettings.motorMax.m2}`;
      document.getElementById('wizard-final-z').textContent = benchSettings.motorMax.m3;
      document.getElementById('wizard-final-grid').textContent = `${cols} √ó ${rows}`;
    }
    
    function finishSetupWizard() {
      // Save all settings
      saveBenchSettings();
      
      // Mark setup as complete
      localStorage.setItem('brionette_setup_complete', 'true');
      localStorage.setItem('brionette_setup_date', new Date().toISOString());
      
      // Close modal
      document.getElementById('setup-wizard-modal').close();
      
      // Create bench grid
      createBenchGrid();
      
      addLog('Setup wizard completed successfully!', 'info');
    }
    
    // ========================================
    // Command Generator
    // ========================================
    let generatedCommands = [];
    
    function generateCommandsFromGraph() {
      generatedCommands = [];
      
      // Find all nodes and their connections
      const nodes = graph._nodes;
      if (!nodes || nodes.length === 0) {
        addLog('No nodes in graph to generate commands', 'warning');
        return [];
      }
      
      // Simple traversal - find button nodes as entry points
      const buttonNodes = nodes.filter(n => n.type === 'util/button');
      
      if (buttonNodes.length === 0) {
        addLog('No Button node found - add a Button to start your flow', 'warning');
        return [];
      }
      
      // Traverse from each button
      buttonNodes.forEach(btn => {
        traverseFromNode(btn, generatedCommands);
      });
      
      return generatedCommands;
    }
    
    // Helper: Get position from a node connected to input (for non-loop context - uses first enabled well)
    function getPositionFromConnectedNode(node, inputName) {
      if (!node.inputs) return null;
      
      const inputIdx = node.inputs.findIndex(inp => inp.name === inputName);
      if (inputIdx === -1) return null;
      
      const input = node.inputs[inputIdx];
      if (!input.link) return null;
      
      const link = graph.links[input.link];
      if (!link) return null;
      
      const sourceNode = graph.getNodeById(link.origin_id);
      if (!sourceNode) return null;
      
      const props = sourceNode.properties || {};
      
      if (sourceNode.type === 'bench/tip-box-96' || sourceNode.type === 'bench/wellplate-96') {
        const enabledWells = props.enabledWells || new Array(96).fill(true);
        
        // Find first enabled well
        let firstEnabledWell = 0;
        for (let i = 0; i < 96; i++) {
          if (enabledWells[i]) {
            firstEnabledWell = i;
            break;
          }
        }
        
        const row = Math.floor(firstEnabledWell / 12);
        const col = firstEnabledWell % 12;
        const spacingX = props.spacingX || 9;
        const spacingY = props.spacingY || 9;
        
        return {
          x: (props.gridX || 0) + (props.offsetX || 0) + col * spacingX,
          y: (props.gridY || 0) + (props.offsetY || 0) + row * spacingY,
          z: props.zPosition || 0,
          label: sourceNode.title || sourceNode.type,
          wellLabel: String.fromCharCode(65 + row) + (col + 1)
        };
      }
      
      if (sourceNode.type === 'bench/reservoir') {
        return {
          x: (props.gridX || 0) + (props.offsetX || 0),
          y: (props.gridY || 0) + (props.offsetY || 0),
          z: props.zPosition || 0,
          label: sourceNode.title || 'Reservoir'
        };
      }
      
      return null;
    }

    function traverseFromNode(node, commands, visited = new Set(), loopContext = null) {
      // Skip bench nodes in traversal - they are data sources, not flow nodes
      if (node.type === 'bench/tip-box-96' || 
          node.type === 'bench/wellplate-96' ||
          node.type === 'bench/reservoir') {
        return;
      }
      
      if (visited.has(node.id)) return;
      visited.add(node.id);
      
      // Handle Loop node specially
      if (node.type === 'util/loop') {
        const min = Math.floor(node.properties?.min || 1);
        const max = Math.floor(node.properties?.max || 10);
        
        // Find nodes connected to "Loop" output
        const loopOutputIdx = node.outputs?.findIndex(o => o.name === 'Loop');
        if (loopOutputIdx !== -1 && node.outputs[loopOutputIdx].links) {
          const loopLinks = node.outputs[loopOutputIdx].links;
          
          // Execute loop iterations
          for (let i = min; i <= max; i++) {
            commands.push({
              type: 'LOOP_ITER',
              iteration: i,
              total: max - min + 1,
              label: `Loop iteration ${i}/${max}`,
              implemented: true
            });
            
            // Traverse loop body for each iteration
            loopLinks.forEach(linkId => {
              const link = graph.links[linkId];
              if (link) {
                const targetNode = graph.getNodeById(link.target_id);
                if (targetNode) {
                  // Create a new visited set for each iteration
                  const iterVisited = new Set([node.id]);
                  traverseFromNode(targetNode, commands, iterVisited, { iteration: i, total: max, loopNode: node });
                }
              }
            });
          }
        }
        
        // Continue to "Done" output after loop completes
        const doneOutputIdx = node.outputs?.findIndex(o => o.name === 'Done');
        if (doneOutputIdx !== -1 && node.outputs[doneOutputIdx].links) {
          node.outputs[doneOutputIdx].links.forEach(linkId => {
            const link = graph.links[linkId];
            if (link) {
              const targetNode = graph.getNodeById(link.target_id);
              if (targetNode) {
                traverseFromNode(targetNode, commands, visited, null);
              }
            }
          });
        }
        return;
      }
      
      // Generate command based on node type
      const cmd = nodeToCommand(node, loopContext);
      if (cmd) {
        if (Array.isArray(cmd)) {
          commands.push(...cmd);
        } else {
          commands.push(cmd);
        }
      }
      
      // Find connected output nodes via Trigger/Done outputs only (flow control)
      if (node.outputs) {
        node.outputs.forEach((output, idx) => {
          // Only follow flow outputs (Done, Trigger, Click, etc.)
          const flowOutputs = ['Done', 'Trigger', 'Click', 'Next', 'Loop'];
          if (!flowOutputs.includes(output.name) && output.name !== '') {
            return; // Skip data outputs like X, Y, Z
          }
          
          if (output.links) {
            output.links.forEach(linkId => {
              const link = graph.links[linkId];
              if (link) {
                const targetNode = graph.getNodeById(link.target_id);
                if (targetNode) {
                  traverseFromNode(targetNode, commands, visited, loopContext);
                }
              }
            });
          }
        });
      }
    }    
    
    // Helper: Get position from connected bench node with loop context
    function getPositionWithLoopContext(node, inputName, loopContext) {
      if (!node.inputs) return null;
      
      const inputIdx = node.inputs.findIndex(inp => inp.name === inputName);
      if (inputIdx === -1) return null;
      
      const input = node.inputs[inputIdx];
      if (!input.link) return null;
      
      const link = graph.links[input.link];
      if (!link) return null;
      
      const sourceNode = graph.getNodeById(link.origin_id);
      if (!sourceNode) return null;
      
      const props = sourceNode.properties || {};
      
      if (sourceNode.type === 'bench/tip-box-96' || sourceNode.type === 'bench/wellplate-96') {
        const enabledWells = props.enabledWells || new Array(96).fill(true);
        
        // Get index: check if bench node's Index input is connected to Loop
        let index = 1; // Default index
        if (loopContext) {
          index = loopContext.iteration;
        }
        
        // Find enabled well at this index (1-based, skipping disabled)
        let count = 0;
        let actualWellId = -1;
        for (let i = 0; i < 96; i++) {
          if (enabledWells[i]) {
            count++;
            if (count === index) {
              actualWellId = i;
              break;
            }
          }
        }
        
        // If index exceeds enabled wells, return invalid or wrap
        if (actualWellId === -1) {
          // Wrap around or use last enabled
          const enabledIndices = enabledWells.map((e, i) => e ? i : -1).filter(i => i >= 0);
          if (enabledIndices.length > 0) {
            actualWellId = enabledIndices[(index - 1) % enabledIndices.length];
          } else {
            actualWellId = 0;
          }
        }
        
        const row = Math.floor(actualWellId / 12);
        const col = actualWellId % 12;
        const spacingX = props.spacingX || 9;
        const spacingY = props.spacingY || 9;
        
        const x = (props.gridX || 0) + (props.offsetX || 0) + col * spacingX;
        const y = (props.gridY || 0) + (props.offsetY || 0) + row * spacingY;
        const z = props.zPosition || 0;
        const wellLabel = String.fromCharCode(65 + row) + (col + 1);
        
        return { x, y, z, label: sourceNode.title || sourceNode.type, wellLabel, wellIndex: actualWellId };
      }
      
      if (sourceNode.type === 'bench/reservoir') {
        return {
          x: (props.gridX || 0) + (props.offsetX || 0),
          y: (props.gridY || 0) + (props.offsetY || 0),
          z: props.zPosition || 0,
          label: sourceNode.title || 'Reservoir'
        };
      }
      
      return null;;
    }
    
    function nodeToCommand(node, loopContext = null) {
      const type = node.type;
      const props = node.properties || {};
      
      switch (type) {
        case 'motor/move': {
          // Check if inputs are connected to get position from bench nodes (with loop context)
          const connectedX = getPositionWithLoopContext(node, 'X (mm)', loopContext);
          const connectedY = getPositionWithLoopContext(node, 'Y (mm)', loopContext);
          const connectedZ = getPositionWithLoopContext(node, 'Z (mm)', loopContext);
          
          const x = connectedX?.x ?? props.x ?? 0;
          const y = connectedY?.y ?? props.y ?? 0;
          const z = connectedZ?.z ?? props.z ?? 0;
          
          let label = `Move to (${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)}) mm`;
          const sourceLabels = [];
          if (connectedX?.wellLabel) sourceLabels.push(`${connectedX.label} ${connectedX.wellLabel}`);
          else if (connectedX?.label) sourceLabels.push(connectedX.label);
          
          if (sourceLabels.length > 0) {
            label = `Move to ${[...new Set(sourceLabels)].join(', ')} (${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)})`;
          }
          
          return {
            type: 'MOVE',
            x: x,
            y: y,
            z: z,
            label: label,
            implemented: true
          };
        }
        
        case 'motor/move_xy': {
          const connectedX = getPositionWithLoopContext(node, 'X (mm)', loopContext);
          const connectedY = getPositionWithLoopContext(node, 'Y (mm)', loopContext);
          
          const x = connectedX?.x ?? props.x ?? 0;
          const y = connectedY?.y ?? props.y ?? 0;
          
          return {
            type: 'MOVE_XY',
            x: x,
            y: y,
            z: null, // Z stays unchanged
            label: `Move XY to (${x.toFixed(1)}, ${y.toFixed(1)}) mm`,
            implemented: true
          };
        }
        
        case 'motor/move_single': {
          const motor = props.motor || 1;
          const position = props.position || 0;
          const axis = motor === 1 ? 'X' : motor === 2 ? 'Y' : 'Z';
          
          return {
            type: 'MOVE_SINGLE',
            motor: motor,
            position: position,
            axis: axis,
            label: `Move Motor ${motor} (${axis}) to ${position.toFixed(1)} mm`,
            implemented: true
          };
        }
        
        case 'motor/move_relative': {
          const motor = props.motor || 1;
          const distance = props.distance || 0;
          const axis = motor === 1 ? 'X' : motor === 2 ? 'Y' : 'Z';
          const sign = distance >= 0 ? '+' : '';
          
          return {
            type: 'MOVE_RELATIVE',
            motor: motor,
            distance: distance,
            axis: axis,
            label: `Move Motor ${motor} (${axis}) ${sign}${distance.toFixed(1)} mm`,
            implemented: true
          };
        }
        
        case 'motor/stop':
          return {
            type: 'STOP',
            label: 'Stop All Motors',
            implemented: true
          };
        
        case 'motor/emergency':
          return {
            type: 'E_STOP',
            label: 'Emergency Stop',
            implemented: true
          };
        
        case 'motor/set_home':
        case 'motor/home':
          return {
            type: 'SET_HOME',
            x: 0, y: 0, z: 0,
            motor: props.motor || 0,
            label: props.motor === 0 || !props.motor ? 'Set Home All' : `Set Home Motor ${props.motor}`,
            implemented: true
          };
        
        case 'motor/wait_idle':
          return {
            type: 'WAIT_IDLE',
            label: 'Wait for Idle',
            implemented: true
          };
        
        case 'motor/enable':
          return {
            type: 'ENABLE',
            motor: props.motor || 0,
            label: props.motor === 0 ? 'Enable All Motors' : `Enable Motor ${props.motor}`,
            implemented: true
          };
        
        case 'motor/disable':
          return {
            type: 'DISABLE',
            motor: props.motor || 0,
            label: props.motor === 0 ? 'Disable All Motors' : `Disable Motor ${props.motor}`,
            implemented: true
          };
        
        case 'motor/set_speed':
          return {
            type: 'SET_SPEED',
            motor: props.motor || 0,
            speed: props.speed || 1000,
            label: props.motor === 0 ? `Set Speed All: ${props.speed}` : `Set Speed Motor ${props.motor}: ${props.speed}`,
            implemented: true
          };
        
        case 'motor/set_accel':
          return {
            type: 'SET_ACCEL',
            motor: props.motor || 0,
            accel: props.accel || 500,
            label: props.motor === 0 ? `Set Accel All: ${props.accel}` : `Set Accel Motor ${props.motor}: ${props.accel}`,
            implemented: true
          };
        
        case 'util/delay':
          return {
            type: 'DELAY',
            ms: props.delay || 1000,
            label: `Wait ${props.delay || 1000}ms`,
            implemented: true
          };
        
        case 'util/button':
          return {
            type: 'START',
            label: 'Start',
            implemented: true
          };
        
        // ===== Pipette Module Commands =====
        case 'pipette/calibrate':
          return {
            type: 'PIPETTE_CALIBRATE',
            label: 'Pipette: Calibrate (Auto Home)',
            implemented: true
          };
        
        case 'pipette/aspirate':
          return {
            type: 'PIPETTE_ASPIRATE',
            volume: props.volume || 100,
            label: `Pipette: Aspirate ${props.volume || 100} ¬µL`,
            implemented: true
          };
        
        case 'pipette/blowout':
          return {
            type: 'PIPETTE_BLOWOUT',
            label: 'Pipette: Blowout Sequence',
            implemented: true
          };
        
        case 'pipette/tip_dispense':
          return {
            type: 'PIPETTE_TIP_DISPENSE',
            label: 'Pipette: Tip Dispense Sequence',
            implemented: true
          };
        
        case 'pipette/default_pos':
          return {
            type: 'PIPETTE_DEFAULT_POS',
            label: 'Pipette: Go to Default Position',
            implemented: true
          };
        
        case 'pipette/set_accel':
          return {
            type: 'PIPETTE_SET_ACCEL',
            accel: props.accel || 1,
            label: `Pipette: Set Accel ${props.accel || 1} rev/s¬≤`,
            implemented: true
          };
        
        case 'pipette/set_speed':
          return {
            type: 'PIPETTE_SET_SPEED',
            speed: props.speed || 3,
            label: `Pipette: Set Speed ${props.speed || 3} rev/s`,
            implemented: true
          };
        
        case 'pipette/stop':
          return {
            type: 'PIPETTE_STOP',
            label: 'Pipette: Stop',
            implemented: true
          };
        
        case 'pipette/emergency':
          return {
            type: 'PIPETTE_ESTOP',
            label: 'Pipette: Emergency Stop',
            implemented: true
          };
        
        case 'pipette/get_position':
          return {
            type: 'PIPETTE_GET_POS',
            label: 'Pipette: Get Position',
            implemented: true
          };
        
        case 'pipette/limit_comp':
          return {
            type: 'PIPETTE_LIMIT_COMP',
            ratio: props.ratio || 1.0,
            label: `Pipette: Set Limit Comp ${props.ratio || 1.0}`,
            implemented: true
          };
        
        default:
          return null;
      }
    }
    
    // ========================================
    // 3D Simulator
    // ========================================
    let simulator = {
      scene: null,
      camera: null,
      renderer: null,
      controls: null,
      toolHead: null,
      trailLine: null,
      trail: [],
      currentStep: 0,
      isPlaying: false,
      playSpeed: 1,
      animationId: null,
      maxBounds: { x: 300, y: 300, z: 100 },
      // Current tracked position
      currentX: 0,
      currentY: 0,
      currentZ: 0,
      // Smooth animation
      isAnimating: false,
      animStartPos: { x: 0, y: 0, z: 0 },
      animTargetPos: { x: 0, y: 0, z: 0 },
      animProgress: 0,
      animDuration: 500 // ms per move
    };
    
    // ========================================
    // Save/Load Functions
    // ========================================
    
    function saveNodesToFile() {
      if (!graph) return;
      
      const data = graph.serialize();
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `graph_${new Date().toISOString().slice(0,10)}.json`;
      a.click();
      
      URL.revokeObjectURL(url);
      console.log('Nodes saved to file');
    }
    
    function loadNodesFromFile(file) {
      if (!file || !graph) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          graph.configure(data);
          console.log('Nodes loaded from file');
        } catch (err) {
          console.error('Failed to load nodes:', err);
          alert('Failed to load nodes file: ' + err.message);
        }
      };
      reader.readAsText(file);
    }
    
    function saveAllConfig() {
      const config = {
        version: 1,
        savedAt: new Date().toISOString(),
        stepSettings: stepSettings,
        benchSettings: benchSettings,
        componentSettings: componentSettings,
        graph: graph ? graph.serialize() : null
      };
      
      const json = JSON.stringify(config, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = `brionette_config_${new Date().toISOString().slice(0,10)}.json`;
      a.click();
      
      URL.revokeObjectURL(url);
      console.log('All config saved to file');
    }
    
    function loadAllConfig(file) {
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const config = JSON.parse(e.target.result);
          
          // Load settings
          if (config.stepSettings) {
            stepSettings = config.stepSettings;
            localStorage.setItem('stepSettings', JSON.stringify(stepSettings));
          }
          if (config.benchSettings) {
            benchSettings = config.benchSettings;
            localStorage.setItem('benchSettings', JSON.stringify(benchSettings));
          }
          if (config.componentSettings) {
            componentSettings = config.componentSettings;
            localStorage.setItem('componentSettings', JSON.stringify(componentSettings));
          }
          
          // Load graph
          if (config.graph && graph) {
            graph.configure(config.graph);
          }
          
          console.log('All config loaded from file');
          alert('Configuration loaded successfully!');
        } catch (err) {
          console.error('Failed to load config:', err);
          alert('Failed to load config file: ' + err.message);
        }
      };
      reader.readAsText(file);
    }
    
    function initSaveLoad() {
      // Save Nodes button
      document.getElementById('btn-save-nodes')?.addEventListener('click', saveNodesToFile);
      
      // Load Nodes button & input
      document.getElementById('btn-load-nodes')?.addEventListener('click', () => {
        document.getElementById('load-nodes-input')?.click();
      });
      
      document.getElementById('load-nodes-input')?.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          loadNodesFromFile(file);
          e.target.value = ''; // Reset input
        }
      });
      
      // Save All Config button
      document.getElementById('btn-save-config')?.addEventListener('click', saveAllConfig);
    }
    
    function initSimulator() {
      // Generate & Simulate button
      document.getElementById('btn-generate-simulate')?.addEventListener('click', () => {
        const commands = generateCommandsFromGraph();
        if (commands.length > 0) {
          openSimulator(commands);
        }
      });
      
      // Playback controls
      document.getElementById('sim-btn-play')?.addEventListener('click', toggleSimPlay);
      document.getElementById('sim-btn-prev')?.addEventListener('click', simPrevStep);
      document.getElementById('sim-btn-next')?.addEventListener('click', simNextStep);
      
      // Speed control
      document.getElementById('sim-speed')?.addEventListener('input', (e) => {
        simulator.playSpeed = parseFloat(e.target.value);
        document.getElementById('sim-speed-value').textContent = simulator.playSpeed + 'x';
      });
      
      // Run on machine button
      document.getElementById('sim-btn-run')?.addEventListener('click', runCommandsOnMachine);
    }
    
    function openSimulator(commands) {
      generatedCommands = commands;
      simulator.currentStep = 0;
      simulator.currentX = 0;
      simulator.currentY = 0;
      simulator.currentZ = 0;
      simulator.trail = [];
      simulator.isPlaying = false;
      simulator.isAnimating = false;
      
      const modal = document.getElementById('simulator-modal');
      modal.showModal();
      
      // Update command count
      document.getElementById('sim-command-count').textContent = commands.length + ' commands';
      document.getElementById('sim-total-steps').textContent = commands.length;
      
      // Render command list
      renderCommandList(commands);
      
      // Initialize Three.js scene after modal is visible
      setTimeout(() => {
        initThreeScene();
        
        // Handle resize
        const handleResize = () => {
          const container = document.getElementById('three-container');
          if (container && simulator.renderer && simulator.camera) {
            const width = container.clientWidth;
            const height = container.clientHeight;
            simulator.camera.aspect = width / height;
            simulator.camera.updateProjectionMatrix();
            simulator.renderer.setSize(width, height);
          }
        };
        
        window.addEventListener('resize', handleResize);
        
        // Remove listener when modal closes
        modal.addEventListener('close', () => {
          window.removeEventListener('resize', handleResize);
          if (simulator.animationId) {
            cancelAnimationFrame(simulator.animationId);
            simulator.animationId = null;
          }
        }, { once: true });
      }, 100);
    }
    
    function renderCommandList(commands) {
      const list = document.getElementById('sim-command-list');
      list.innerHTML = '';
      
      commands.forEach((cmd, idx) => {
        const item = document.createElement('div');
        const isImplemented = cmd.implemented !== false;
        item.className = `p-2 rounded cursor-pointer hover:bg-base-300 transition-colors ${!isImplemented ? 'opacity-40' : ''}`;
        item.id = `sim-cmd-${idx}`;
        item.innerHTML = `
          <span class="badge badge-xs ${isImplemented ? 'badge-ghost' : 'badge-warning'} mr-1">${idx + 1}</span>
          ${cmd.label}
          ${!isImplemented ? '<span class="badge badge-xs badge-outline ml-1">N/A</span>' : ''}
        `;
        item.onclick = () => goToStep(idx);
        list.appendChild(item);
      });
      
      // Generate raw commands
      renderRawCommands(commands);
    }
    
    function renderRawCommands(commands) {
      const rawEl = document.getElementById('sim-raw-commands');
      const lines = ['// Raw commands for motor_controller.js', '// Generated from graph', ''];
      
      commands.forEach((cmd, idx) => {
        if (cmd.implemented === false) {
          lines.push(`// [${idx + 1}] SKIP: ${cmd.label} (not implemented)`);
          return;
        }
        
        switch (cmd.type) {
          case 'MOVE':
          case 'POSITION': {
            const stepsX = mmToSteps(cmd.x, 'm1');
            const stepsY = mmToSteps(cmd.y, 'm2');
            const stepsZ = mmToSteps(cmd.z, 'm3');
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.moveAll(${stepsX}, ${stepsY}, ${stepsZ});`);
            lines.push(`await controller.waitForIdle();`);
            lines.push('');
            break;
          }
          
          case 'MOVE_XY': {
            const sX = mmToSteps(cmd.x, 'm1');
            const sY = mmToSteps(cmd.y, 'm2');
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.send('${sX},${sY}');`);
            lines.push(`await controller.waitForIdle();`);
            lines.push('');
            break;
          }
          
          case 'MOVE_SINGLE': {
            const steps = mmToSteps(cmd.position, `m${cmd.motor}`);
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.send('${cmd.motor}:${steps}');`);
            lines.push(`await controller.waitForIdle();`);
            lines.push('');
            break;
          }
          
          case 'MOVE_RELATIVE': {
            const steps = mmToSteps(Math.abs(cmd.distance), `m${cmd.motor}`);
            const sign = cmd.distance >= 0 ? '+' : '-';
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.send('${cmd.motor}:${sign}${steps}');`);
            lines.push(`await controller.waitForIdle();`);
            lines.push('');
            break;
          }
          
          case 'STOP':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.stop();`);
            lines.push('');
            break;
          
          case 'E_STOP':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.emergencyStop();`);
            lines.push('');
            break;
          
          case 'HOME':
          case 'SET_HOME':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            if (cmd.motor === 0) {
              lines.push(`await controller.setHome();`);
            } else {
              lines.push(`await controller.send('${cmd.motor}:h');`);
            }
            lines.push('');
            break;
          
          case 'WAIT_IDLE':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            if (cmd.timeout) {
              lines.push(`await controller.waitForIdle(${cmd.timeout});`);
            } else {
              lines.push(`await controller.waitForIdle();`);
            }
            lines.push('');
            break;
          
          case 'ENABLE':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            if (cmd.motor === 0) {
              lines.push(`await controller.enable();`);
            } else {
              lines.push(`await controller.enable(${cmd.motor});`);
            }
            lines.push('');
            break;
          
          case 'DISABLE':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            if (cmd.motor === 0) {
              lines.push(`await controller.disable();`);
            } else {
              lines.push(`await controller.disable(${cmd.motor});`);
            }
            lines.push('');
            break;
          
          case 'SET_SPEED':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            if (cmd.motor === 0) {
              lines.push(`await controller.setSpeed(${cmd.speed});`);
            } else {
              lines.push(`await controller.send('${cmd.motor}:x${cmd.speed}');`);
            }
            lines.push('');
            break;
          
          case 'SET_ACCEL':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            if (cmd.motor === 0) {
              lines.push(`await controller.setAcceleration(${cmd.accel});`);
            } else {
              lines.push(`await controller.send('${cmd.motor}:a${cmd.accel}');`);
            }
            lines.push('');
            break;
          
          case 'DELAY':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await new Promise(r => setTimeout(r, ${cmd.ms}));`);
            lines.push('');
            break;
          
          case 'LOOP_ITER':
            lines.push(`// [${idx + 1}] --- ${cmd.label} ---`);
            break;
          
          case 'START':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            break;
          
          // ===== Pipette Module Commands =====
          case 'PIPETTE_CALIBRATE':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.executeToolCommand({ cmd: 'c', isQueue: true });`);
            lines.push('');
            break;
          
          case 'PIPETTE_ASPIRATE':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.executeToolCommand({ cmd: 'u', inputType: 'float', isQueue: true }, ${cmd.volume});`);
            lines.push('');
            break;
          
          case 'PIPETTE_BLOWOUT':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.executeToolCommand({ cmd: 'b', isQueue: true });`);
            lines.push('');
            break;
          
          case 'PIPETTE_TIP_DISPENSE':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.executeToolCommand({ cmd: 'k', isQueue: true });`);
            lines.push('');
            break;
          
          case 'PIPETTE_DEFAULT_POS':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.executeToolCommand({ cmd: 'u', isQueue: true });`);
            lines.push('');
            break;
          
          case 'PIPETTE_SET_ACCEL':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.sendImmediate('ma${cmd.accel}');`);
            lines.push('');
            break;
          
          case 'PIPETTE_SET_SPEED':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.sendImmediate('mx${cmd.speed}');`);
            lines.push('');
            break;
          
          case 'PIPETTE_STOP':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.sendImmediate('ms');`);
            lines.push('');
            break;
          
          case 'PIPETTE_ESTOP':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.sendImmediate('me');`);
            lines.push('');
            break;
          
          case 'PIPETTE_GET_POS':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.sendImmediate('mp');`);
            lines.push('');
            break;
          
          case 'PIPETTE_LIMIT_COMP':
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`await controller.sendImmediate('mi${cmd.ratio}');`);
            lines.push('');
            break;
            
          default:
            lines.push(`// [${idx + 1}] ${cmd.label}`);
            lines.push(`// Unknown command type: ${cmd.type}`);
            lines.push('');
        }
      });
      
      rawEl.textContent = lines.join('\n');
    }
    
    function switchCommandTab(tab) {
      const tabCommands = document.getElementById('tab-commands');
      const tabRaw = document.getElementById('tab-raw');
      const viewCommands = document.getElementById('view-commands');
      const viewRaw = document.getElementById('view-raw');
      
      if (tab === 'commands') {
        tabCommands.classList.add('tab-active');
        tabRaw.classList.remove('tab-active');
        viewCommands.classList.remove('hidden');
        viewRaw.classList.add('hidden');
      } else {
        tabCommands.classList.remove('tab-active');
        tabRaw.classList.add('tab-active');
        viewCommands.classList.add('hidden');
        viewRaw.classList.remove('hidden');
      }
    }
    
    function initThreeScene() {
      const container = document.getElementById('three-container');
      if (!container) return;
      
      // Clear previous
      container.innerHTML = '';
      
      // Scene
      simulator.scene = new THREE.Scene();
      simulator.scene.background = new THREE.Color(0x1e1e2e);
      
      // Camera
      const aspect = container.clientWidth / container.clientHeight;
      simulator.camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 2000);
      simulator.camera.position.set(400, 300, 400);
      simulator.camera.lookAt(150, 0, 150);
      
      // Renderer
      simulator.renderer = new THREE.WebGLRenderer({ antialias: true });
      simulator.renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(simulator.renderer.domElement);
      
      // Controls
      if (THREE.OrbitControls) {
        simulator.controls = new THREE.OrbitControls(simulator.camera, simulator.renderer.domElement);
        simulator.controls.target.set(150, 0, 150);
        simulator.controls.enableDamping = true;
        simulator.controls.dampingFactor = 0.05;
        simulator.controls.enableZoom = true;
        simulator.controls.enablePan = true;
        simulator.controls.enableRotate = true;
        simulator.controls.minDistance = 50;
        simulator.controls.maxDistance = 1500;
        simulator.controls.update();
      }
      
      // Update bounds from settings
      simulator.maxBounds = {
        x: benchSettings.motorMax?.m1 || 300,
        y: benchSettings.motorMax?.m2 || 300,
        z: benchSettings.motorMax?.m3 || 100
      };
      
      // Grid
      const gridHelper = new THREE.GridHelper(
        Math.max(simulator.maxBounds.x, simulator.maxBounds.y),
        10,
        0x45475a,
        0x313244
      );
      gridHelper.position.set(simulator.maxBounds.x / 2, 0, simulator.maxBounds.y / 2);
      simulator.scene.add(gridHelper);
      
      // Axes
      const axesHelper = new THREE.AxesHelper(50);
      simulator.scene.add(axesHelper);
      
      // Work area bounds (wireframe box)
      const boundsGeometry = new THREE.BoxGeometry(
        simulator.maxBounds.x,
        simulator.maxBounds.z,
        simulator.maxBounds.y
      );
      const boundsMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x89b4fa, 
        wireframe: true, 
        opacity: 0.3, 
        transparent: true 
      });
      const boundsMesh = new THREE.Mesh(boundsGeometry, boundsMaterial);
      boundsMesh.position.set(
        simulator.maxBounds.x / 2,
        simulator.maxBounds.z / 2,
        simulator.maxBounds.y / 2
      );
      simulator.scene.add(boundsMesh);
      
      // Tool head (cone pointing down)
      const coneGeometry = new THREE.ConeGeometry(8, 20, 8);
      const coneMaterial = new THREE.MeshBasicMaterial({ color: 0xa6e3a1 });
      simulator.toolHead = new THREE.Mesh(coneGeometry, coneMaterial);
      simulator.toolHead.rotation.x = Math.PI; // Point downward
      simulator.toolHead.position.set(0, simulator.maxBounds.z, 0);
      simulator.scene.add(simulator.toolHead);
      
      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      simulator.scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
      directionalLight.position.set(100, 100, 100);
      simulator.scene.add(directionalLight);
      
      // Trail line
      const trailMaterial = new THREE.LineBasicMaterial({ color: 0xf9e2af });
      const trailGeometry = new THREE.BufferGeometry();
      simulator.trailLine = new THREE.Line(trailGeometry, trailMaterial);
      simulator.scene.add(simulator.trailLine);
      simulator.trail = [];
      
      // Start render loop
      animateSimulator();
      
      // Go to first step
      updateSimulatorStep();
    }
    
    let lastFrameTime = 0;
    
    function animateSimulator(currentTime = 0) {
      simulator.animationId = requestAnimationFrame(animateSimulator);
      
      const deltaTime = currentTime - lastFrameTime;
      lastFrameTime = currentTime;
      
      if (simulator.controls) {
        simulator.controls.update();
      }
      
      // Smooth animation interpolation
      if (simulator.isAnimating && simulator.toolHead) {
        const speed = simulator.playSpeed * 2; // Faster with higher speed
        simulator.animProgress += (deltaTime / simulator.animDuration) * speed;
        
        if (simulator.animProgress >= 1) {
          simulator.animProgress = 1;
          simulator.isAnimating = false;
          
          // Auto-advance to next step when playing
          if (simulator.isPlaying && simulator.currentStep < generatedCommands.length - 1) {
            setTimeout(() => {
              simulator.currentStep++;
              startStepAnimation();
            }, 100 / simulator.playSpeed);
          } else if (simulator.isPlaying && simulator.currentStep >= generatedCommands.length - 1) {
            // Reached end, stop playing
            simulator.isPlaying = false;
            updatePlayButton();
          }
        }
        
        // Easing function (ease-in-out)
        const t = simulator.animProgress;
        const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        
        // Interpolate position
        const x = simulator.animStartPos.x + (simulator.animTargetPos.x - simulator.animStartPos.x) * eased;
        const y = simulator.animStartPos.y + (simulator.animTargetPos.y - simulator.animStartPos.y) * eased;
        const z = simulator.animStartPos.z + (simulator.animTargetPos.z - simulator.animStartPos.z) * eased;
        
        simulator.toolHead.position.set(x, y, z);
        
        // Update position display (convert back to our coordinate system)
        const displayX = x;
        const displayY = z;
        const displayZ = simulator.maxBounds.z - y;
        document.getElementById('sim-pos-x').textContent = displayX.toFixed(2);
        document.getElementById('sim-pos-y').textContent = displayY.toFixed(2);
        document.getElementById('sim-pos-z').textContent = displayZ.toFixed(2);
      }
      
      if (simulator.renderer && simulator.scene && simulator.camera) {
        simulator.renderer.render(simulator.scene, simulator.camera);
      }
    }
    
    function startStepAnimation() {
      const step = simulator.currentStep;
      const cmd = generatedCommands[step];
      
      document.getElementById('sim-current-step').textContent = step + 1;
      
      // Highlight current command in list
      document.querySelectorAll('[id^="sim-cmd-"]').forEach((el, idx) => {
        el.classList.toggle('bg-primary/30', idx === step);
      });
      
      // Scroll command into view
      const cmdEl = document.getElementById(`sim-cmd-${step}`);
      if (cmdEl) {
        cmdEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
      
      if (!cmd) {
        // No command, skip to next if playing
        if (simulator.isPlaying && simulator.currentStep < generatedCommands.length - 1) {
          simulator.currentStep++;
          startStepAnimation();
        }
        return;
      }
      
      // Calculate target position based on command type
      let hasMovement = false;
      let targetX = simulator.currentX;
      let targetY = simulator.currentY;
      let targetZ = simulator.currentZ;
      
      if (cmd.type === 'MOVE' || cmd.type === 'POSITION') {
        targetX = cmd.x || 0;
        targetY = cmd.y || 0;
        targetZ = cmd.z !== undefined ? cmd.z : 0;
        hasMovement = true;
      } else if (cmd.type === 'MOVE_XY') {
        targetX = cmd.x || 0;
        targetY = cmd.y || 0;
        // Keep current Z!
        hasMovement = true;
      } else if (cmd.type === 'HOME' || cmd.type === 'SET_HOME') {
        targetX = 0;
        targetY = 0;
        targetZ = 0;
        hasMovement = true;
      } else if (cmd.type === 'MOVE_SINGLE') {
        if (cmd.motor === 1) targetX = cmd.position || 0;
        else if (cmd.motor === 2) targetY = cmd.position || 0;
        else if (cmd.motor === 3) targetZ = cmd.position || 0;
        hasMovement = true;
      } else if (cmd.type === 'MOVE_RELATIVE') {
        if (cmd.motor === 1) targetX += cmd.distance || 0;
        else if (cmd.motor === 2) targetY += cmd.distance || 0;
        else if (cmd.motor === 3) targetZ += cmd.distance || 0;
        hasMovement = true;
      }
      
      if (hasMovement) {
        // Update tracked position
        simulator.currentX = targetX;
        simulator.currentY = targetY;
        simulator.currentZ = targetZ;
        
        // In Three.js: X = our X, Y = our Z (height), Z = our Y
        const threeTargetX = targetX;
        const threeTargetY = simulator.maxBounds.z - targetZ;
        const threeTargetZ = targetY;
        
        if (simulator.toolHead) {
          // Store start position
          simulator.animStartPos = {
            x: simulator.toolHead.position.x,
            y: simulator.toolHead.position.y,
            z: simulator.toolHead.position.z
          };
          
          // Store target position
          simulator.animTargetPos = {
            x: threeTargetX,
            y: threeTargetY,
            z: threeTargetZ
          };
          
          // Calculate animation duration based on distance
          const dx = threeTargetX - simulator.animStartPos.x;
          const dy = threeTargetY - simulator.animStartPos.y;
          const dz = threeTargetZ - simulator.animStartPos.z;
          const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
          simulator.animDuration = Math.max(200, Math.min(1000, distance * 3));
          
          // Start animation
          simulator.animProgress = 0;
          simulator.isAnimating = true;
          
          // Add to trail when animation completes
          setTimeout(() => {
            simulator.trail.push(new THREE.Vector3(threeTargetX, threeTargetY, threeTargetZ));
            updateTrailLine();
          }, simulator.animDuration / simulator.playSpeed);
        }
      } else {
        // Non-movement command (DELAY, LOOP_ITER, START, STOP, E_STOP, ENABLE, DISABLE, etc.)
        if (simulator.isPlaying) {
          // Wait appropriate time for delays
          const waitTime = cmd.type === 'DELAY' ? Math.min(cmd.ms / simulator.playSpeed, 1000) : 200 / simulator.playSpeed;
          setTimeout(() => {
            if (simulator.currentStep < generatedCommands.length - 1) {
              simulator.currentStep++;
              startStepAnimation();
            } else {
              simulator.isPlaying = false;
              updatePlayButton();
            }
          }, waitTime);
        }
      }
    }
    
    function updateSimulatorStep() {
      // This is called for immediate jumps (prev/next buttons, clicking on command)
      simulator.isAnimating = false;
      
      const step = simulator.currentStep;
      const cmd = generatedCommands[step];
      
      document.getElementById('sim-current-step').textContent = step + 1;
      
      // Highlight current command in list
      document.querySelectorAll('[id^="sim-cmd-"]').forEach((el, idx) => {
        el.classList.toggle('bg-primary/30', idx === step);
      });
      
      if (!cmd) return;
      
      // Update position based on command type
      let x = simulator.currentX;
      let y = simulator.currentY;
      let z = simulator.currentZ;
      
      if (cmd.type === 'MOVE' || cmd.type === 'POSITION') {
        // Full XYZ move
        x = cmd.x || 0;
        y = cmd.y || 0;
        z = cmd.z !== undefined ? cmd.z : 0;
      } else if (cmd.type === 'MOVE_XY') {
        // XY only - preserve current Z
        x = cmd.x || 0;
        y = cmd.y || 0;
        // z stays the same
      } else if (cmd.type === 'HOME' || cmd.type === 'SET_HOME') {
        // Home position
        x = 0; y = 0; z = 0;
      } else if (cmd.type === 'MOVE_SINGLE') {
        // Single motor move
        if (cmd.motor === 1) x = cmd.position || 0;
        else if (cmd.motor === 2) y = cmd.position || 0;
        else if (cmd.motor === 3) z = cmd.position || 0;
      } else if (cmd.type === 'MOVE_RELATIVE') {
        // Relative move
        if (cmd.motor === 1) x += cmd.distance || 0;
        else if (cmd.motor === 2) y += cmd.distance || 0;
        else if (cmd.motor === 3) z += cmd.distance || 0;
      }
      
      // Update tracked position
      simulator.currentX = x;
      simulator.currentY = y;
      simulator.currentZ = z;
      
      // In Three.js: X = our X, Y = our Z (height), Z = our Y
      if (simulator.toolHead) {
        simulator.toolHead.position.set(x, simulator.maxBounds.z - z, y);
        
        // Add to trail for movement commands
        if (cmd.type === 'MOVE' || cmd.type === 'MOVE_XY' || cmd.type === 'POSITION' || 
            cmd.type === 'MOVE_SINGLE' || cmd.type === 'MOVE_RELATIVE') {
          simulator.trail.push(new THREE.Vector3(x, simulator.maxBounds.z - z, y));
          updateTrailLine();
        }
      }
      
      // Update position display
      document.getElementById('sim-pos-x').textContent = x.toFixed(2);
      document.getElementById('sim-pos-y').textContent = y.toFixed(2);
      document.getElementById('sim-pos-z').textContent = z.toFixed(2);
    }
    
    function updateTrailLine() {
      if (simulator.trail.length < 2) return;
      
      const positions = new Float32Array(simulator.trail.length * 3);
      simulator.trail.forEach((point, i) => {
        positions[i * 3] = point.x;
        positions[i * 3 + 1] = point.y;
        positions[i * 3 + 2] = point.z;
      });
      
      simulator.trailLine.geometry.setAttribute(
        'position',
        new THREE.BufferAttribute(positions, 3)
      );
      simulator.trailLine.geometry.setDrawRange(0, simulator.trail.length);
    }
    
    function goToStep(step) {
      simulator.currentStep = Math.max(0, Math.min(step, generatedCommands.length - 1));
      
      // Reset position and trail, rebuild up to current step
      simulator.currentX = 0;
      simulator.currentY = 0;
      simulator.currentZ = 0;
      simulator.trail = [];
      
      for (let i = 0; i <= simulator.currentStep; i++) {
        const cmd = generatedCommands[i];
        if (!cmd) continue;
        
        let x = simulator.currentX;
        let y = simulator.currentY;
        let z = simulator.currentZ;
        
        if (cmd.type === 'MOVE' || cmd.type === 'POSITION') {
          x = cmd.x || 0;
          y = cmd.y || 0;
          z = cmd.z !== undefined ? cmd.z : 0;
        } else if (cmd.type === 'MOVE_XY') {
          x = cmd.x || 0;
          y = cmd.y || 0;
          // z stays the same
        } else if (cmd.type === 'HOME' || cmd.type === 'SET_HOME') {
          x = 0; y = 0; z = 0;
        } else if (cmd.type === 'MOVE_SINGLE') {
          if (cmd.motor === 1) x = cmd.position || 0;
          else if (cmd.motor === 2) y = cmd.position || 0;
          else if (cmd.motor === 3) z = cmd.position || 0;
        } else if (cmd.type === 'MOVE_RELATIVE') {
          if (cmd.motor === 1) x += cmd.distance || 0;
          else if (cmd.motor === 2) y += cmd.distance || 0;
          else if (cmd.motor === 3) z += cmd.distance || 0;
        }
        
        simulator.currentX = x;
        simulator.currentY = y;
        simulator.currentZ = z;
        
        // Add trail for movement commands
        if (cmd.type === 'MOVE' || cmd.type === 'MOVE_XY' || cmd.type === 'POSITION' ||
            cmd.type === 'MOVE_SINGLE' || cmd.type === 'MOVE_RELATIVE') {
          simulator.trail.push(new THREE.Vector3(x, simulator.maxBounds.z - z, y));
        }
      }
      
      updateTrailLine();
      
      // Update UI
      const x = simulator.currentX;
      const y = simulator.currentY;
      const z = simulator.currentZ;
      
      if (simulator.toolHead) {
        simulator.toolHead.position.set(x, simulator.maxBounds.z - z, y);
      }
      
      document.getElementById('sim-pos-x').textContent = x.toFixed(2);
      document.getElementById('sim-pos-y').textContent = y.toFixed(2);
      document.getElementById('sim-pos-z').textContent = z.toFixed(2);
      document.getElementById('sim-current-step').textContent = simulator.currentStep + 1;
      
      document.querySelectorAll('[id^="sim-cmd-"]').forEach((el, idx) => {
        el.classList.toggle('bg-primary/30', idx === simulator.currentStep);
      });
    }
    
    function simNextStep() {
      if (simulator.currentStep < generatedCommands.length - 1) {
        simulator.currentStep++;
        updateSimulatorStep();
      }
    }
    
    function simPrevStep() {
      if (simulator.currentStep > 0) {
        simulator.currentStep--;
        goToStep(simulator.currentStep);
      }
    }
    
    function updatePlayButton() {
      const btn = document.getElementById('sim-btn-play');
      if (simulator.isPlaying) {
        btn.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6" />
          </svg>
        `;
      } else {
        btn.innerHTML = `
          <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
          </svg>
        `;
      }
    }
    
    function toggleSimPlay() {
      simulator.isPlaying = !simulator.isPlaying;
      updatePlayButton();
      
      if (simulator.isPlaying) {
        // Reset to start if at end
        if (simulator.currentStep >= generatedCommands.length - 1) {
          simulator.currentStep = 0;
          simulator.trail = [];
          if (simulator.toolHead) {
            simulator.toolHead.position.set(0, simulator.maxBounds.z, 0);
          }
        }
        // Start smooth animation
        startStepAnimation();
      } else {
        // Stop animation
        simulator.isAnimating = false;
      }
    }
    
    async function runCommandsOnMachine() {
      if (!controller || !controller.isConnected) {
        addLog('Not connected to controller', 'error');
        return;
      }
      
      if (generatedCommands.length === 0) {
        addLog('No commands to run', 'warning');
        return;
      }
      
      document.getElementById('simulator-modal').close();
      
      addLog(`Running ${generatedCommands.length} commands...`, 'info');
      
      for (let i = 0; i < generatedCommands.length; i++) {
        const cmd = generatedCommands[i];
        
        // Skip non-implemented commands
        if (!cmd.implemented) {
          addLog(`[${i + 1}/${generatedCommands.length}] SKIP: ${cmd.label} (not implemented)`, 'warning');
          continue;
        }
        
        addLog(`[${i + 1}/${generatedCommands.length}] ${cmd.label}`, 'info');
        
        try {
          switch (cmd.type) {
            case 'MOVE':
            case 'POSITION':
              // Convert mm to steps and send
              const stepsX = mmToSteps(cmd.x, 'm1');
              const stepsY = mmToSteps(cmd.y, 'm2');
              const stepsZ = mmToSteps(cmd.z, 'm3');
              await controller.moveAll(stepsX, stepsY, stepsZ);
              await controller.waitForIdle();
              break;
            
            case 'MOVE_XY':
              // Move X and Y only, Z stays
              const sX = mmToSteps(cmd.x, 'm1');
              const sY = mmToSteps(cmd.y, 'm2');
              await controller.send(`${sX},${sY}`);
              await controller.waitForIdle();
              break;
            
            case 'HOME':
              if (cmd.motor === 0) {
                await controller.setHome();
              } else {
                await controller.setHome(cmd.motor);
              }
              break;
            
            case 'DELAY':
              await new Promise(resolve => setTimeout(resolve, cmd.ms));
              break;
            
            case 'LOOP_ITER':
            case 'START':
              // These are informational only, no action needed
              break;
            
            default:
              addLog(`Unknown command type: ${cmd.type}`, 'warning');
          }
        } catch (err) {
          addLog(`Error: ${err.message}`, 'error');
        }
      }
      
      addLog('All commands completed!', 'info');
    }
  </script>
</body>
</html>
